#+title:TypeScript Guide
#+author:Pinecone062
#+date:2019-08-16 09:35
#+macro:version 0.0.14

#+texinfo:@insertcopying

* Source Installation and Update
#+cindex:source
#+cindex:installation
#+cindex:updating

** About TypeScript
TypeScript is a superset of JavaScript that compiles to clean
JavaScript output.

- https://www.typescriptlang.org

** Source Code Repository
TypeScript is being developed on GitHub and is open source.

- https://github.com/Microsoft/TypeScript

** Installation

Installation is performed by Node:

#+name:installation
#+option: :results output :exports none
#+begin_src sh :shebang "#!/usr/bin/env bash"
yarn global add typescript
#+end_src

** Nightly Builds
- [[http://www.typescriptlang.org/docs/handbook/nightly-builds.html][Nightly Builds home]]
- The nightlies are available on [[https://www.myget.org/gallery/typescript-preview][www.myget.org]]

There are two packages:

- Microsoft.TypeScript.Compiler :: Tools only (~tsc.exe~, ~lib.d.ts~,
     etc.)

- Microsoft.TypeScript.MSBuild :: Tools as above, as well as MSBuild
     tasks and targets (Microsoft.TypeScript.targets,
     Microsoft.TypeScript.Default.props, etc.)


{{{heading(Using npm)}}}

A nightly build from the TypeScript’s master branch is published by
midnight PST to NPM and NuGet.  Here is how you can get it and use it
with your tools:

: npm install -g typescript@next

* Configuration and Compilation

** The ~tsconfig~ File
#+cindex:schema, @file{tsconfig.json}
#+cindex:@file{tsconfig.json} schema
Schema for the ~tsconfig.json~ file can be found at:
- http://json.schemastore.org/tsconfig


#+cindex:@file{tsconfig.json} file
#+cindex: configuration
#+cindex:TypeScript project
#+cindex:project, TypeScript
#+cindex:root files, TypeScript project
#+cindex:compiler options
The presence of a ~tsconfig.json~ file in a directory indicates that
the directory is the root of a TypeScript project.

A ~tsconfig.json~ file specifies:

- the root files
- the compiler options


{{{noindent}}}required to compile the project.

A ~tsconfig.json~ file is permitted to be completely empty, which
compiles all files included by default with the default compiler
options.  Compiler options specified on the command line override
those specified in the ~tsconfig.json~ file.

*** The =compilerOptions= Property
#+cindex:@code{compilerOptions} property
#+cindex:default compiler options
#+cindex:compiler options, defaults
The =compilerOptions= property can be omitted, in which case the
compiler’s defaults are used.

**** List of Compiler Options
For a complete list of compiler options, see:
- http://www.typescriptlang.org/docs/handbook/compiler-options.html


#+cindex:compiler options, list
#+attr_texinfo: :indic code
- --allowJs :: boolean =false=
- --allowSyntheticDefaultImports :: boolean module === "system" or
     --esModuleInterop
- --allowUmdGlobalAccess :: boolean =false=
- --allowUnreachableCode :: boolean =false=
- --allowUnusedLabels :: boolean =false=
- --alwaysStrict :: boolean false
- --baseUrl :: string; See [[http://www.typescriptlang.org/docs/handbook/module-resolution.html#base-url][Module Resolution documentation]]
- --build -b :: boolean =false=
- --charset :: string "utf8"
- --checkJs :: boolean =false=
- --composite :: boolean =true=
- --declaration -d :: boolean =false=
- --declarationDir :: string
- --declarationMap :: boolean =false=
- --diagnostics :: boolean =false=
- --disableSizeLimit :: boolean =false=
- --downlevelIteration :: boolean =false=
- --emitBOM :: boolean =false=
- --emitDeclarationOnly :: boolean =false=
- --emitDecoratorMetadata :: boolean =false=
- --esModuleInterop :: boolean =false=
- --experimentalDecorators :: boolean =false=
- --extendedDiagnostics :: boolean =false=
- --forceConsistentCasingInFileNames :: boolean =false=
- --help -h :: empty
- --importHelpers :: boolean =false=
- --incremental :: boolean =true= if composite; =false= otherwise
- --inlineSourceMap :: boolean =false=
- --inlineSources :: boolean =false=
- --init :: empty
- --isolatedModules :: boolean =false=
- --jsx :: string "preserve" | "react" | "react-native"
- --jsxFactory :: string "React.createElement" | "h"
- --keyofStringsOnly :: boolean =false=
- --lib :: string[] [default list of libraries are injected]
- --listEmittedFiles :: boolean =false=
- --listFiles :: boolean =false=
- --locale :: string "en"
- --mapRoot :: string
- --maxNodeModuleJsDepth :: number 0
- --module -m :: string target === "ES3" or "ES5" ? "CommonJS" : "ES6"
- --moduleResolution :: string module === "AMD" or "System" or "ES6" ?
     "Classic" : "Node"
- --newLine :: string "lf"
- --noEmit :: boolean =false=
- --noEmitHelpers :: boolean =false=
- --noEmitOnError :: boolean =false=
- --noErrorTruncation :: boolean =false=
- --noFallthroughCasesInSwitch :: boolean =false=
- --noImplicitAny :: boolean =false=
- --noImplicitReturns :: boolean =false=
- --noImplicitThis :: boolean =false=
- --noImplicitUseStrict :: boolean =false=
- --noLib :: boolean =false=
- --noResolve :: boolean =false=
- --noStrictGenericChecks :: boolean =false=
- --noUnusedLocals :: boolean =false=
- --noUnusedParameters :: boolean =false=
- --outDir :: string
- --outFile :: string
- paths :: Object
- --preserveConstEnums :: boolean =false=
- --preserveSymlinks :: boolean =false=
- --preserveWatchOutput :: boolean =false=
- --pretty :: boolean =true= unless piping or redirecting
- --project -p :: string
- --reactNamespace :: deprecated; use {{{option(--jsxFactory)}}}
- --removeComments :: boolean =false=
- --resolveJsonModule :: boolean =false=
- --rootDir :: string [computed from input files]
- rootDirs :: string[]
- --showConfig :: boolean =false=
- --skipDefaultLibCheck :: boolean =false=
- --skipLibCheck :: boolean =false=
- --sourceMap :: boolean =false=
- --sourceRoot :: string
- --strict :: boolean =false=
- --strictBindCallApply :: boolean =false=
- --strictFunctionTypes :: boolean =false=
- --strictPropertyInitialization :: boolean =false=
- --strictNullChecks :: boolean =false=
- --suppressExcessPropertyErrors :: boolean =false=
- --suppressImplicitAnyIndexErrors :: boolean =false=
- --target -t :: string "ES3"
- --traceResolution :: boolean =false=
- --tsBuildInfoFile :: boolean =false=
- --types :: string[]
- --typeRoots :: string[]
- --version -v :: [empty]
- --watch -w :: [empty]

*** The =files= and =include= and =exclude= Properties

#+cindex:@code{files} property
#+cindex:@code{include} property
#+cindex:@code{exclude} property
Files and can included or excluded from a project by using a
combination of the =files=, the =include=, and the =exclude=
properties, and the =outDir= compiler option in the ~tsconfig.json~
file.

{{{subheading(Include Defaults)}}}

If the =files= and =include= properties are both left unspecified, the
compiler defaults to including all TypeScript files in the containing
directory and subdirectories except those excluded using the =exclude=
property.  (See below for default extensions.)  JS files (see below)
are also included if =allowJs= is set to =true=.

{{{subheading(Including Files)}}}

If the =files= and/or =include= properties are specified, the compiler
will instead include the union of the files included by those two
properties.

Any files that are referenced via the =files= or =include= properties
are included.  Files included using =include= can be filtered using
the =exclude= property, but files included explicitly using the
=files= property are always included regardless of =exclude=.

Files in the directory specified using the =outDir= compiler option
are excluded as long as =exclude= property is /not/ specified.

If a file ~B.ts~ is referenced by another file ~A.ts~, then ~B.ts~
cannot be excluded unless the referencing file ~A.ts~ is also
specified in the =exclude= list.  The compiler does not include files
that can be possible outputs; e.g. if the input includes ~index.ts~,
then ~index.d.ts~ and ~index.js~ are excluded.

**** The =files= Property
#+cindex:@code{files} property
The =files= property takes a list of relative or absolute file paths.

**** The =include= and =exclude= Properties
#+cindex:@code{include} property
#+cindex:@code{exclude} property
#+cindex:glob patterns
#+cindex:wildcards, glob
The =include= and =exclude= properties take a list of glob-like file
patterns.  The supported glob wildcards are:

- =*= :: matches zero or more characters (excluding directory
         separators)

         If a segment of a glob pattern includes only =*= or =.*=,
         then only files with supported extensions are included.
         Supported extensions include:

  - =.ts=

  - =.tsx=

  - =.d.ts=

    If =allowJs= is set to =true=:

  - =.js=

  - =.jsx=

- =?= :: matches any one character (excluding directory separators)

- =**/= :: recursively matches any subdirectory


#+cindex:@file{node_modules}
#+cindex:@file{bower_components}
#+cindex:@file{jspm_packages}
#+cindex:@code{outDir} property
=exclude= by default excludes the following directories:

- ~node_modules~
- ~bower_components~
- ~jspm_packages~
- =outDir=

**** Including and Excluding Types Packages

#+cindex:types package
#+cindex:@file{index.d.ts} file
#+cindex:@code{types} field
A /types package/ is a folder with a file called ~index.d.ts~ or a
folder with a ~package.json~ that has a =types= field.

{{{subheading(Include @types Packages)}}}

#+cindex:@code{@@types} packages
By default all visible =@@types= packages are included in your
compilation.  Packages in ~node_modules/@types~ of any enclosing
folder are considered visible.  That means packages within the
following directores are visible:

- ~./node_modules/@types/~
- ~../node_modules/@types/~
- ~../../node_modules/@types/~


Automatic inclusion is only important if you’re using files with
global declarations (as opposed to files declared as modules).  If you
use an =import "foo"= statement, for instance, TypeScript may still
look through ~node_modules~ and ~node_modules/@types~ folders to find
the ~foo~ package.

{{{subheading(Exclude @types Packages)}}}

Specify ="types": []= to disable automatic inclusion of =@types=
packages.

{{{heading(typeRoots)}}}

If =typeRoots= is specified, only packages under =typeRoots= will be
included.  This config file will include all packages under
~./typings~, and no packages from ~./node_modules/@types~.

#+begin_src js
{
   "compilerOptions": {
       "typeRoots" : ["./typings"]
   }
}
#+end_src

{{{heading(types)}}}

If types is specified, only packages listed will be included.  This
~tsconfig.json~ file will only include ~./node_modules/@types/node~,
~./node_modules/@types/lodash~ and ~./node_modules/@types/express~.
Other packages under ~node_modules/@types/*~ will not be included.

#+begin_src js
{
   "compilerOptions": {
       "types" : ["node", "lodash", "express"]
   }
}
#+end_src

*** Example tsconfig.json Files
{{{heading("Files" Property)}}}

#+caption:tsconfig.json using the "files" property
#+name:tsconfig.json-using-files-property
#+begin_src js -n
{
    "compilerOptions": {
        "module": "commonjs",
        "noImplicitAny": true,
        "removeComments": true,
        "preserveConstEnums": true,
        "sourceMap": true
    },
    "files": [
        "core.ts",
        "sys.ts",
        "types.ts",
        "scanner.ts",
        "parser.ts",
        "utilities.ts",
        "binder.ts",
        "checker.ts",
        "emitter.ts",
        "program.ts",
        "commandLineParser.ts",
        "tsc.ts",
        "diagnosticInformationMap.generated.ts"
    ]
}
#+end_src

{{{heading("Include" and "Exclude" Properties)}}}

#+caption:tsconfig using the "include" and "exclude" properties
#+name:tsconfig.json-using-include-and-exclude-properties
#+begin_src js -n
{
    "compilerOptions": {
        "module": "system",
        "noImplicitAny": true,
        "removeComments": true,
        "preserveConstEnums": true,
        "outFile": "../../built/local/tsc.js",
        "sourceMap": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.spec.ts"
    ]
}
#+end_src
*** Extending Configuration
A ~tsconfig.json~ file can inherit configurations from another file
using the =extends= property.  The =extends= property is a top-level
property, along with =compilerOptions=, =files=, =includes=, and
=excludes.=.  The =extends= value is a string containing a path to
another configuration file to inherit from.

The configuration from the base file is loaded first, then overridden
by those in the inheriting config file.  If a circularity is
encountered, an error is reported.  All relative paths found in the
configuration file will be resolved relative to the configuration file
they originated in.

**** Example ~tsconfig.json~ Using =extends=
#+name:configs-base.json
#+begin_src js
{
  "compilerOptions": {
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
#+end_src

#+name:tsconfig.json-using-extends
#+begin_src js
{
  "extends": "./configs/base",
  "files": [
    "main.ts",
    "supplemental.ts"
  ]
}
#+end_src

#+name:tsconfig-nostrictnull
#+begin_src js
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "strictNullChecks": false
  }
}
#+end_src

*** CompileOnSave
Setting a top-level property =compileOnSave= signals to the IDE to
generate all files for a given ~tsconfig.json~ upon saving.  This
feature is currently supported in Visual Studio 2015 with TypeScript
1.8.4 and above, and atom-typescript plugin.

#+name:tsconfig.json-compile-on-save
#+begin_src js
{
   "compileOnSave": true,
   "compilerOptions": {
       "noImplicitAny" : true
   }
}
#+end_src

** Compilation of a TypeScript Project

#+cindex:compilation
#+cindex:@file{tsconfig.json}
A project is compiled:

{{{heading(Using tsconfig.json)}}}

- By invoking {{{command(tsc)}}} with no input files, in which case
  the compiler searches for the ~tsconfig.json~ file starting in the
  current directory and continuing up the parent directory chain.

- By invoking {{{command(tsc)}}} with no input files and an
  {{{option(--project)}}} (or just {{{option(-p)}}}) command line
  option that specifies the path of a directory containing a
  ~tsconfig.json~ file, or a path to a valid ~.json~ file containing
  the configurations.


{{{heading(With Input Files)}}}

- By invoking {{{command(tsc)}}} with input files on the command line,
  in which case a ~tsconfig.json~ files are ignored.

** Project References
- http://www.typescriptlang.org/docs/handbook/project-references.html


#+cindex:project reference
/Project references/ are a new feature in TypeScript 3.0 that allow
you to structure your TypeScript programs into smaller pieces.  By
doing this, you can:

- greatly improve build times
- enforce logical separation between components
- organize your code in new and better ways


There is also a new mode for {{{command(tsc)}}}, the
{{{option(--build)}}} flag that works hand in hand with project
references to enable faster TypeScript builds.

*** The =references= Property
~tsconfig.json~ files have a new top-level property, =references=.
It’s an array of objects that specifies projects to reference:

#+name:tsconfig-with-references
#+begin_src js
{
    "compilerOptions": {
        // The usual
    },
    "references": [
        { "path": "../src" }
    ]
}
#+end_src

The =path= property of each reference can point to a directory
containing a ~tsconfig.json~ file, or to the config file itself (which
may have any name).

When you reference a project, new things happen:

- Importing modules from a referenced project will instead load its
  output declaration file (~.d.ts~)

- If the referenced project produces an =outFile=, the output file
  ~.d.ts~ file’s declarations will be visible in this project

- Build mode (see below) will automatically build the referenced
  project if needed


By separating into multiple projects, you can greatly improve the
speed of typechecking and compiling, reduce memory usage when using an
editor, and improve enforcement of the logical groupings of your
program

*** The =composite= Property
Referenced projects must have the new =composite= setting enabled.
This setting is needed to ensure TypeScript can quickly determine
where to find the outputs of the referenced project.

Enabling the composite flag changes a few things:

- The =rootDir= setting, if not explicitly set, defaults to the
  directory containing the ~tsconfig~ file

- All implementation files must be matched by an =include= pattern or
  listed in the files array.  If this constraint is violated, ~tsc~
  will inform you which files weren’t specified

- =declaration= must be turned on

*** The =prepend= Property
You can also enable prepending the output of a dependency using the
=prepend= option in a reference:

#+name:tsconfig-using-prepend
#+begin_src js
"references": [
       { "path": "../utils", "prepend": true }
   ]
#+end_src

Prepending a project will include the project’s output above the
output of the current project.  This works for both ~.js~ files and
~.d.ts~ files, and source map files will also be emitted correctly.

*** Build Mode
To preserve compatibility with existing build workflows, ~tsc~ will
not automatically build dependencies unless invoked with the
{{{option(--build)}}} switch.

A long-awaited feature is /smart incremental builds/ for TypeScript
projects.  In 3.0 you can use the {{{option(--build)}}} flag with
~tsc~.  This is effectively a new entry point for ~tsc~ that behaves
more like a build orchestrator than a simple compiler.

Running ~tsc --build~ (~tsc -b~ for short) will do the following:

- Find all referenced projects

- Detect if they are up-to-date

- Build out-of-date projects in the correct order


You can provide ~tsc -b~ with multiple config file paths (e.g. ~tsc -b
src test~).  Specifying the config file name itself is unnecessary if
it’s named ~tsconfig.json~.

You can specify any number of config files:

#+begin_example
> tsc -b                            # Use the tsconfig.json in the current directory
> tsc -b src                        # Use src/tsconfig.json
> tsc -b foo/prd.tsconfig.json bar  # Use foo/prd.tsconfig.json and bar/tsconfig.json
#+end_example

There are also some flags specific to tsc -b:

#+attr_texinfo: :indic option
- --verbose :: Prints out verbose logging to explain what’s going on
               (may be combined with any other flag)

- --dry :: Shows what would be done but doesn’t actually build anything

- --clean :: Deletes the outputs of the specified projects (may be
             combined with {{{option(--dry)}}})

- --force :: Act as if all projects are out of date

- --watch :: Watch mode (may not be combined with any flag except
             {{{option(--verbose)}}})

** Integrating with Build Tools

#+cindex:build tools
*** Babel
#+cindex:babel
{{{heading(Install Babel)}}}

: npm install @babel/cli @babel/core @babel/preset-typescript --save-dev

#+cindex:@file{.babelrc}
{{{heading(.babelrc File)}}}

#+begin_src js
{
  "presets": ["@babel/preset-typescript"]
}
#+end_src

{{{heading(Using Command Line Interface)}}}

: ./node_modules/.bin/babel --out-file bundle.js src/index.ts

{{{heading(package.json File)}}}

#+begin_src js
{
  "scripts": {
    "build": "babel --out-file bundle.js main.ts"
  },
}
#+end_src

{{{heading(Execute Babel from the command line)}}}

: npm run build
*** Browserify
{{{heading(Install Browserify)}}}

: npm install tsify

See:
- [[https://github.com/TypeStrong/tsify][tsify---Browsify plugin for TypeScript]]

{{{heading(Using Command Line Interface)}}}

: $ browserify main.ts -p [ tsify --noImplicitAny ] > bundle.js

{{{heading(Using API)}}}

#+begin_src js
var browserify = require("browserify");
var tsify = require("tsify");

browserify()
    .add("main.ts")
    .plugin("tsify", { noImplicitAny: true })
    .bundle()
    .pipe(process.stdout);
#+end_src
*** Duo
~due-typescript~: The typescript compiler plugin for ~duo~

See:
- [[https://github.com/frankwallis/duo-typescript][due-typescript]]
*** Grunt
TypeScript Compilation Task for GruntJS

{{{heading(Install grunt-ts)}}}

: npm install grunt-ts

See:
- [[https://github.com/TypeStrong/grunt-ts][grunt-ts]]

{{{heading(Basic Gruntfile.js File)}}}

#+begin_src js
module.exports = function(grunt) {
    grunt.initConfig({
        ts: {
            default : {
                src: ["**/*.ts", "!node_modules/**/*.ts"]
            }
        }
    });
    grunt.loadNpmTasks("grunt-ts");
    grunt.registerTask("default", ["ts"]);
};
#+end_src
*** Gulp
- [[https://github.com/ivogabe/gulp-typescript][gulp-typescript]] :: A gulp plugin for handling TypeScript compilation
     workflow.

{{{heading(Install gulp-typescript)}}}

: npm install gulp-typescript

{{{heading(Basic gulpfile.js)}}}

#+begin_src js
var gulp = require("gulp");
var ts = require("gulp-typescript");

gulp.task("default", function () {
    var tsResult = gulp.src("src/*.ts")
        .pipe(ts({
              noImplicitAny: true,
              out: "output.js"
        }));
    return tsResult.js.pipe(gulp.dest("built/local"));
});
#+end_src
*** Jspm
- [[https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm][jspm]]
*** Webpack
- [[https://www.npmjs.com/package/ts-loader][ts-loader]] :: TypeScript loader for webpack

{{{heading(Install ts-loader)}}}

: npm install ts-loader --save-dev

{{{heading(Basic webpack.config.js when using Webpack 2)}}}

#+begin_src js
module.exports = {
    entry: "./src/index.tsx",
    output: {
        path: '/',
        filename: "bundle.js"
    },
    resolve: {
        extensions: [".tsx", ".ts", ".js", ".json"]
    },
    module: {
        rules: [
            // all files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'
            { test: /\.tsx?$/, use: ["ts-loader"], exclude: /node_modules/ }
        ]
    }
}
#+end_src
* Types
#+cindex:types
** Boolean
#+cindex:boolean type
- =true=
- =false=


: let isDone: boolean = false;

** Number
#+cindex:number type
All numbers are floating-point values; numbers include binary, octal,
hexadecimal and decimal literals.

: let decimal: number = 6;
: let hex: number = 0xf00d;
: let binary: number = 0b1010;
: let octal: number = 0o744;

** String
#+cindex:string type
The type =string= refers to the textual datatype.  TypeScript uses
either double quotes or single quotes to surround string data.

: let color: string = "blue";
: color = 'red';

{{{heading(Template Strings)}}}

Template strings are strings surrounded by the backtick or backquote
character (=`=); template strings can span multiple lines and allow
embedded expressions using the syntax =${ expr }=.

: let sentence: string = `Hello, my name is ${ fullName }.`

** Array
#+cindex:array type
Array types can be written in one of two ways.

In the first, you use the type of the elements followed by =[]= to
denote an array of that element type:

: let list: number[] = [1, 2, 3];

The second way uses a generic array type, =Array<elemType>=:

: let list: Array<number> = [1, 2, 3];

** Tuple
#+cindex:tuple type
Tuple types allow you to express an array with a fixed number of
elements whose types are known, but need not be the same.

To represent a value as a pair of a string and a number:

#+begin_src js
// Declare a tuple type
let x: [string, number];
// Initialize it
x = ["hello", 10]; // OK
// Initialize it incorrectly
x = [10, "hello"]; // Error
#+end_src

When accessing an element with a known index, the correct type is
retrieved:

: console.log(x[0].substring(1)); // OK

** Enum
#+cindex:enum type
An enum is a way of giving more friendly names to sets of numeric
values.

#+begin_src js
enum Color {Red, Green, Blue}
let c: Color = Color.Green;
#+end_src

{{{heading(Enum Numbering)}}}

By default, enums begin numbering their members starting at 0.  You
can change this by manually setting the value of one of its members.
For example, we can start the previous example at 1 instead of 0:

#+begin_src js
enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;
#+end_src

{{{subheading(Manual Enum Numbering)}}}

Or, even manually set all the values in the enum:

#+begin_src js
enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
#+end_src

{{{subheading(Enum Values to Name)}}}

A handy feature of enums is that you can also go from a numeric value
to the name of that value in the enum.  For example, if we had the
value 2 but weren’t sure what that mapped to in the Color enum above,
we could look up the corresponding name:

#+begin_src js
enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

console.log(colorName); // Displays 'Green' as its value is 2 above
#+end_src

** Any
#+cindex:any type
We may need to describe the type of variables that we do not know when
we are writing an application.  These values may come from dynamic
content, e.g. from the user or a 3rd party library.  In these cases,
we want to opt-out of type checking and let the values pass through
compile-time checks.  To do so, we label these with the =any= type:

#+begin_src js
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean
#+end_src

{{{heading(Objects and Type =any=)}}}

Variables of type =Object= only allow you to assign =any= value to
them.  You can’t call arbitrary methods on them, even ones that
actually exist:

#+begin_src js
let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.
#+end_src

The =any= type is also handy if you know some part of the type, but
perhaps not all of it.  For example, you may have an array but the
array has a mix of different types:

#+begin_src js
let list: any[] = [1, true, "free"];

list[1] = 100;
#+end_src

** Void
#+cindex:void type
The =void= type denotes the absence of having any type at all.  You
may commonly see this as the return type of functions that do not
return a value:

#+begin_src js
function warnUser(): void {
    console.log("This is my warning message");
}
#+end_src

Declaring variables of type =void= is not useful because you can only
assign =undefined= or =null= to them.

** Null
#+cindex:null type
The type =null= is the only value of this type.  It is a subtype of
all other types, though, which means you can assign =null= to any
other type, unless {{{option(--strictNullChecks)}}} is used, in which
case =null= can only be assigned to an =any= type.

** Undefined
#+cindex:undefined type
The type =undefined= is the only value of this type.  It is a subtype
of all other types as is =null=.  When
{{{option(--stringNullChecks)}}} is used, =undefined= can be assigned
to a type of =any= and =void=.

** Union Type
#+cindex:union type
In cases where you want to pass in either a =string= or =null= or
=undefined=, you can use the =union= type =string | null | undefined=.

** Never
#+cindex:never type
The =never= type represents the type of values that never occur.  For
instance, =never= is the return type for a function expression or an
arrow function expression that always throws an exception or one that
never returns.  Variables also acquire the type =never= when narrowed by
any type guards that can never be true.

The =never= type is a subtype of, and assignable to, every type;
however, no type is a subtype of, or assignable to, =never= (including
=any=).

Some examples of functions returning never:

#+begin_src js
// Function returning never must have unreachable end point
function error(message: string): never {
    throw new Error(message);
}

// Inferred return type is never
function fail() {
    return error("Something failed");
}

// Function returning never must have unreachable end point
function infiniteLoop(): never {
    while (true) {
    }
}
#+end_src

** Object
#+cindex:object type
The =object= is a type that represents the non-primitive type,
i.e. anything that is not =number=, =string=, =boolean=, =symbol=,
=null=, or =undefined=.

With object type, APIs like ~Object.create~ can be better
represented.  For example:

#+begin_src js
declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
#+end_src

** Type Assertions
#+cindex:type assertions
Sometimes you’ll end up in a situation where you’ll know more about a
value than TypeScript does. Usually this will happen when you know the
type of some entity could be more specific than its current type.

/Type assertions/ are a way to tell the compiler “trust me, I know
what I’m doing.”  A type assertion is like a type cast in other
languages, but performs no special checking or restructuring of data.
It has no runtime impact, and is used purely by the compiler.
TypeScript assumes that you, the programmer, have performed any
special checks that you need.

Type assertions have two forms (that is, the forms are equivalent
symantically).

1. the “angle-bracket” syntax:

#+begin_src js
let someValue: any = "this is a string";

let strLength: number = (<string>someValue).length;
#+end_src

2. the other is the as-syntax:

#+begin_src js
let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
#+end_src

When using TypeScript with JSX, only =as=-style assertions are
allowed.
* Variables
** Var
*** Var Scoping Rules
{{{heading(Function Scope)}}}

#+cindex:function scope
#+cindex:@code{var} declaration
=var= declarations are accessible anywhere within their containing
function, module, namespace, or global scope regardless of the
containing block.  Parameters are also function scoped.

{{{subheading(Problems with Function Scope)}}}

One problem they exacerbate is the fact that it is not an error to
declare the same variable multiple times.  Variables can be
accidentally overwritten this way.

This also occurs within for-loops:

#+begin_src js
for (var i = 0; i < 10; i++) {
    setTimeout(function() { console.log(i); }, 100 * i);
}
#+end_src

{{{noindent}}}which produces the following output:

#+begin_example
10
10
10
10
10
10
10
10
10
10
#+end_example

~setTimeout~ will run a function after some number of milliseconds,
but only after the for loop has stopped executing; by the time the for
loop has stopped executing, the value of ~i~ is 10.  So each time the
given function gets called, it will print out 10!

#+cindex:IIFE
#+cindex:immediately invoked function expression
A common work around is to use an IIFE - an Immediately Invoked
Function Expression - to capture ~i~ at each iteration:

#+begin_src js
for (var i = 0; i < 10; i++) {
    // capture the current state of 'i'
    // by invoking a function with its current value
    (function(i) {
        setTimeout(function() { console.log(i); }, 100 * i);
    })(i);
}
#+end_src

The ~i~ in the parameter list actually shadows the ~i~ declared in the
for loop, and which is used to invoke the function.  The function
closes over the value of the parameter ~i~ when it is invoked, and
will be available to the ~setTimeout~ function when it runs much
later.

** Let
#+cindex:lexical scope
#+cindex:block scope
#+cindex:local variable
The =let= statement declares a block scope local variable, optionally
initializing it to a value.  The other difference between =var= and
=let= is that the latter is initialized to value only when parser
evaluates it.  The =let= does not create properties of the window
object when declared globally.  The main difference between =var= and
=let= is that the scope of a =var= variable is the entire enclosing
function.

#+begin_src js
var x = 'global';
let y = 'global';
console.log(this.x); // "global"
console.log(this.y); // undefined
#+end_src

When a variable is declared using ~let~, it uses what some call
lexical-scoping or block-scoping.  Unlike variables declared with
~var~, whose scopes leak out to their containing function,
block-scoped variables are not visible outside of their nearest
containing block or =for-loop=.

#+cindex:temporal dead zone
Another property of block-scoped variables is that they can’t be read
or written to before they’re actually declared.  While these variables
are “present” throughout their scope, all points up until their
declaration are part of their temporal dead zone.  This is just a
sophisticated way of saying you can’t access them before the ~let~
statement, and luckily TypeScript will let you know that.

You can still capture a block-scoped variable before it’s declared.
The only catch is that it’s illegal to call that function before the
declaration.  If targeting ES2015, a modern runtime will throw an
error; however, right now TypeScript is permissive and won’t report
this as an error.

#+begin_src js
function foo() {
    // okay to capture 'a'
    return a;
}

// illegal call 'foo' before 'a' is declared
// runtimes should throw an error here
foo();

let a;
#+end_src

*** Emulate Private Members
#+cindex:private member
In dealing with constructors it is possible to use the ~let~ bindings
to share one or more private members without using closures:

#+caption:Emulate private members using let
#+name:emulate-private-members-using-let
#+begin_src js -n
var Thing;

{ // BLOCK SCOPE
  let privateScope = new WeakMap(); // PRIVATE MEMBERS
  let counter = 0;

  Thing = function() {
    this.someProperty = 'foo';

    privateScope.set(this, {
      hidden: ++counter,
    });
  };

  Thing.prototype.showPublic = function() {
    return this.someProperty;
  };

  Thing.prototype.showPrivate = function() {
    return privateScope.get(this).hidden;
  };
}

console.log(typeof privateScope); // "undefined"

var thing = new Thing();

console.log(thing); // Thing {someProperty: "foo"}

thing.showPublic(); // "foo"

thing.showPrivate(); // 1
#+end_src

The same privacy pattern with closures over local variables can be
created with ~var~, but those need a function scope (typically an IIFE
in the module pattern) instead of just a block scope like in the
example above.

*** Temporal Dead Zone
Unlike variables declared with ~var~, which will start with the value
undefined, ~let~ variables are not initialized until their definition
is evaluated.  Accessing the variable before the initialization
results in a =ReferenceError=.  The variable is in a "temporal dead
zone" from the start of the block until the initialization is
processed.

Unlike with simply undeclared variables and variables that hold a
value of =undefined=, using the ~typeof~ operator to check for the
type of a variable in that variable's TDZ will throw a
=ReferenceError=:

** Const
~const~ declarations are another way of declaring variables.  They are
like ~let~ declarations but, as their name implies, their value cannot
be changed once they are bound.  In other words, they have the same
scoping rules as ~let~, but you can’t re-assign to them.  This should
not be confused with the idea that the values they refer to are
immutable.  Unless you take specific measures to avoid it, the
internal state of a ~const~ variable is still modifiable.
Fortunately, TypeScript allows you to specify that members of an
object are =readonly=

{{{heading(Principle of Least Privilege)}}}

#+cindex:least privilege
Applying the principle of /least privilege/, all declarations other
than those you plan to modify should use ~const~.  The rationale is
that if a variable didn’t need to get written to, others working on
the same codebase shouldn’t automatically be able to write to the
object, and will need to consider whether they really need to reassign
to the variable.  Using ~const~ also makes code more predictable when
reasoning about flow of data.
** Destructuring
*** Array Destructuring
#+cindex:destructuring
#+cindex:array destructuring
The simplest form of destructuring is array destructuring assignment:

#+begin_src js
let input = [1, 2];
let [first, second] = input; // first := 1, second := 2
#+end_src

This creates two new variables named first and second.  This is
equivalent to using indexing, but is much more convenient:

#+begin_src js
first = input[0];
second = input[1];
#+end_src

Destructuring works with already-declared variables as well:

#+begin_src js
// swap variables
[first, second] = [second, first];
#+end_src

And with parameters to a function:

#+begin_src js
function f([first, second]: [number, number]) {
    console.log(first);
    console.log(second);
}
f([1, 2]);
#+end_src

You can create a variable for the remaining items in a list using the
syntax ...:

#+begin_src js
let [first, ...rest] = [1, 2, 3, 4];
console.log(first); // outputs 1
console.log(rest); // outputs [ 2, 3, 4 ]
#+end_src

Of course, since this is JavaScript, you can just ignore trailing
elements you don’t care about:

#+begin_src js
let [first] = [1, 2, 3, 4];
console.log(first); // outputs 1
#+end_src

Or other elements:

#+begin_src js
let [, second, , fourth] = [1, 2, 3, 4];
console.log(second); // outputs 2
console.log(fourth); // outputs 4
#+end_src

*** Tuple Destructuring
#+cindex:destructuring
#+cindex:tuple destructuring
Tuples may be destructured like arrays; the destructuring variables
get the types of the corresponding tuple elements:

#+begin_src js
let tuple: [number, string, boolean] = [7, "hello", true];

let [a, b, c] = tuple; // a: number, b: string, c: boolean
#+end_src

It’s an error to destructure a tuple beyond the range of its elements.
As with arrays, you can destructure the rest of the tuple with ..., to
get a shorter tuple; and ignore trailing elements, or other elements.

*** Object Destructuring
#+cindex:destructuing
#+cindex:object destructuring
You can also destructure objects:

#+begin_src js
let o = {
    a: "foo",
    b: 12,
    c: "bar"
};
Let { a, b } = o;
#+end_src

This creates new variables ~a~ and ~b~ from ~o.a~ and ~o.b~.  Notice
that you can skip ~c~ if you don’t need it.

Like array destructuring, you can have assignment without declaration:

#+begin_src js
({ a, b } = { a: "baz", b: 101 });
#+end_src

Notice that we had to surround this statement with
parentheses. JavaScript normally parses a ={= as the start of block.

You can create a variable for the remaining items in an object using
the syntax ...:

#+begin_src js
let { a, ...passthrough } = o;
let total = passthrough.b + passthrough.c.length;
#+end_src

{{{heading(Property Renaming)}}}

#+pindex:property renaming
You can also give different names to properties:

#+begin_src js
let { a: newName1, b: newName2 } = o;
#+end_src

You can read ~a: newName1~ as “a as newName1”.  The direction is
left-to-right, as if you had written:

#+begin_src js
let newName1 = o.a;
let newName2 = o.b;
#+end_src

Confusingly, the colon here does not indicate the type.  The type, if
you specify it, still needs to be written after the entire
destructuring:

#+begin_src js
let { a, b }: { a: string, b: number } = o;
#+end_src

{{{heading(Default Values)}}}

#+cindex:default values
Default values let you specify a default value in case a property is
=undefined=:

#+begin_src js
function keepWholeObject(wholeObject: { a: string, b?: number }) {
    let { a, b = 1001 } = wholeObject;
}
#+end_src

In this example the ~b?~ indicates that ~b~ is optional, so it may be
=undefined=.  ~keepWholeObject~ now has a variable for ~wholeObject as
well as the properties ~a~ and ~b~, even if ~b~ is =undefined=.

*** Function Declarations and Destructuring
#+cindex:destructuring
#+cindex:function declarations and destructuring
Destructuring also works in function declarations. For simple cases
this is straightforward:

#+begin_src js
type C = { a: string, b?: number }
function f({ a, b }: C): void {
    // ...
}
#+end_src

But specifying defaults is more common for parameters, and getting
defaults right with destructuring can be tricky.  First of all, you
need to remember to put the pattern before the default value.

#+begin_src js
function f({ a="", b=0 } = {}): void {
    // ...
}
f();
#+end_src

Then, you need to remember to give a default for optional properties
on the destructured property instead of the main initializer.  Remember
that ~C~ was defined with ~b~ optional:

#+begin_src js
function f({ a, b=0 } = { a: "" }): void {
    // ...
}
f({ a: "yes" }); // ok, default b = 0
f(); // ok, default to { a: "" }, which then defaults b = 0
f({}); // error, 'a' is required if you supply an argument
#+end_src

Use destructuring with care.  As the previous example demonstrates,
anything but the simplest destructuring expression is confusing.  This
is especially true with deeply nested destructuring, which gets really
hard to understand even without piling on renaming, default values,
and type annotations.  Try to keep destructuring expressions small and
simple.  You can always write the assignments that destructuring would
generate yourself.
** Spreading
#+cindex:@code{spread} operator
#+cindex:spreading
The =spread= operator is the opposite of destructuring.  It allows you
to spread an array into another array, or an object into another
object.  For example:

#+begin_src js
let first = [1, 2];
let second = [3, 4];
let bothPlus = [0, ...first, ...second, 5];
#+end_src

#+cindex:shallow copy, @code{spread} operator
This gives ~bothPlus~ the value =[0, 1, 2, 3, 4, 5]=.  Spreading
creates a shallow copy of first and second.  They are not changed by
the spread.

You can also spread objects:

#+begin_src js
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { ...defaults, food: "rich" };
#+end_src

Now search is ={ food: "rich", price: "$$", ambiance: "noisy" }=.
Object spreading is more complex than array spreading.  Like array
spreading, it proceeds from left-to-right, but the result is still an
object.  This means that properties that come later in the spread
object overwrite properties that come earlier.  So if we modify the
previous example to spread at the end:

#+begin_src js
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { food: "rich", ...defaults };
#+end_src

Then the =food= property in defaults overwrites =food: "rich"=, which
is not what we want in this case.

Object spread also has a couple of other surprising limits.  First, it
only includes an objects’ own, enumerable properties.  Basically, that
means you lose methods when you spread instances of an object:

#+begin_src js
class C {
  p = 12;
  m() {
  }
}
let c = new C();
let clone = { ...c };
clone.p; // ok
clone.m(); // error!
#+end_src

Second, the Typescript compiler doesn’t allow spreads of type
parameters from generic functions.  That feature is expected in future
versions of the language.
* Interfaces
#+cindex:interfaces, introduction
#+cindex:duck typing
#+cindex:structural subtyping
One of TypeScript’s core principles is that type checking focuses on
the shape that values have.  This is sometimes called “duck typing” or
“structural subtyping”.  In TypeScript, interfaces fill the role of
naming these types, and are a powerful way of defining contracts
within your code as well as contracts with code outside of your
project.

{{{heading(A Simple Interface)}}}

#+begin_src js
function printLabel(labeledObj: { label: string }) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
#+end_src

The type checker checks the call to ~printLabel~.  The ~printLabel~
function has a single parameter that requires that the object passed
in has a property called =label= of type =string=.  Notice that our
object actually has more properties than this, but the compiler only
checks that at least the ones required are present and match the types
required.

We can write the same example again, this time using an interface to
describe the requirement of having the =label= property that is a
=string=:

#+begin_src js
interface LabeledValue {
    label: string;
}

function printLabel(labeledObj: LabeledValue) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
#+end_src

The interface =LabeledValue= is a name we can now use to describe the
requirement in the previous example.  It still represents having a
single property called =label= that is of type =string=.  Notice we
didn’t have to explicitly say that the object we pass to ~printLabel~
implements this interface like we might have to in other languages.
Here, it’s only the shape that matters.  If the object we pass to the
function meets the requirements listed, then it’s allowed.

It’s worth pointing out that the type checker does not require that
these properties come in any sort of order, only that the properties
the interface requires are present and have the required type.

** Optional Properties
#+cindex:interface, optional property
#+cindex:option bag
Not all properties of an interface may be required.  Some exist under
certain conditions or may not be there at all.  These optional
properties are popular when creating patterns like “option bags” where
you pass an object to a function that only has a couple of properties
filled in.

Here’s an example of this pattern:

#+caption:Example of an Interface with optional Properties
#+name:interface-with-optional-properties
#+begin_src js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    let newSquare = {color: "white", area: 100};
    if (config.color) {
        newSquare.color = config.color;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
#+end_src

Interfaces with optional properties are written similar to other
interfaces, with each optional property denoted by a =?= at the end of
the property name in the declaration.

The advantage of optional properties is that you can describe these
possibly available properties while still also preventing use of
properties that are not part of the interface.  For example, had we
mistyped the name of the color property in ~createSquare~, we would get
an error message letting us know:

#+begin_src js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    let newSquare = {color: "white", area: 100};
    if (config.clor) {
        // Error: Property 'clor' does not exist on type 'SquareConfig'
        newSquare.color = config.clor;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
#+end_src

** Read-Only Properties
Some properties should only be modifiable when an object is first
created.  You can specify this by putting =readonly= before the name
of the property:

#+begin_src js
interface Point {
    readonly x: number;
    readonly y: number;
}
#+end_src

You can construct a Point by assigning an object literal. After the
assignment, x and y can’t be changed.

#+begin_src js
let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
#+end_src

TypeScript comes with a =ReadonlyArray<T>= type that is the same as
=Array<T>= with all mutating methods removed, so you can make sure you
don’t change your arrays after creation:

#+begin_src js
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
#+end_src

On the last line of the snippet you can see that even assigning the
entire =ReadonlyArray= back to a normal array is illegal.  You can
still override it with a type assertion, though:

#+begin_src js
a = ro as number[];
#+end_src

The easiest way to remember whether to use =readonly= or =const= is to
ask whether you’re using it on a variable or a property.  Variables
use =const= whereas properties use =readonly=.
** Excess Property Checks
In our first example using interfaces, TypeScript lets us pass ={
size: number; label: string; }= to something that only expected a ={
label: string; }=.  We also just learned about optional properties,
and how they’re useful when describing so-called “option bags”.

However, combining the two naively would allow an error to sneak
in.  For example, taking our last example using ~createSquare~:

#+begin_src js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}

let mySquare = createSquare({ colour: "red", width: 100 });
#+end_src

Notice the given argument to ~createSquare~ is spelled =colour= instead of
=color=.  In plain JavaScript, this sort of thing fails silently.

You could argue that this program is correctly typed, since the
=width= properties are compatible, there’s no =color= property
present, and the extra =colour= property is insignificant.

However, TypeScript takes the stance that there’s probably a bug in
this code.  Object literals get special treatment and undergo /excess
property checking/ when assigning them to other variables, or passing
them as arguments.  If an object literal has any properties that the
“target type” doesn’t have, you’ll get an error:

#+begin_src js
// error: Object literal may only specify known properties, but
// 'colour' does not exist in type 'SquareConfig'. Did you mean to
// write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });
#+end_src

#+cindex:type assertion
Getting around these checks is actually really simple.  The easiest
method is to just use a /type assertion/:

#+begin_src js
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
#+end_src

However, a better approach might be to add a /string index signature/
if you’re sure that the object can have some extra properties that are
used in some special way.  If =SquareConfig= can have =color= and
=width= properties with the above types, but could also have any
number of other properties, then we could define it like so:

#+begin_src js
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
#+end_src

Here we’re saying a =SquareConfig= can have any number of properties,
and as long as they aren’t =color= or =width=, their types don’t
matter.

One final way to get around these checks, which might be a bit
surprising, is to assign the object to another variable: Since
~squareOptions~ won’t undergo excess property checks, the compiler
won’t give you an error.

#+begin_src js
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
#+end_src

The above workaround will work as long as you have a common property
between ~squareOptions~ and =SquareConfig=.  In this example, it was
the property =width=.  It will however, fail if the variable does not
have any common object property.  For example:

#+begin_src js
let squareOptions = { colour: "red" };
let mySquare = createSquare(squareOptions);
#+end_src

Keep in mind that for simple code like above, you probably shouldn’t
be trying to “get around” these checks.  For more complex object
literals that have methods and hold state, you might need to keep
these techniques in mind, but a majority of excess property errors are
actually bugs.  That means if you’re running into excess property
checking problems for something like option bags, you might need to
revise some of your type declarations.  In this instance, if it’s okay
to pass an object with both a =color= or =colour= property to
~createSquare~, you should fix up the definition of =SquareConfig= to
reflect that.
** Function Types
#+cindex:interfaces and function types
#+cindex:funtion types, and interfaces
Interfaces are capable of describing the wide range of shapes that
JavaScript objects can take.  In addition to describing an object with
properties, interfaces are also capable of describing function types.

#+cindex:call signature
To describe a function type with an interface, we give the interface a
/call signature/.  This is like a function declaration with only the
parameter list and return type given.  Each parameter in the parameter
list requires both name and type.

#+begin_src js
interface SearchFunc {
    (source: string, subString: string): boolean;
}
#+end_src

Once defined, we can use this function type interface like we would
other interfaces.  Here, we show how you can create a variable of a
function type and assign it a function value of the same type.

#+begin_src js
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    let result = source.search(subString);
    return result > -1;
}
#+end_src

For function types to correctly type check, the names of the
parameters do not need to match.  We could have, for example, written
the above example like this:

#+begin_src js
let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
    let result = src.search(sub);
    return result > -1;
}
#+end_src

#+cindex:contextual typing
#+cindex:inference, type
#+cindex:type inference
Function parameters are checked one at a time, with the type in each
corresponding parameter position checked against each other.  If you
do not want to specify types at all, TypeScript’s /contextual typing/
can /infer/ the argument types since the function value is assigned
directly to a variable of type =SearchFunc=.  Here, also, the return
type of our function expression is implied by the values it returns
(here =false= and =true=).  Had the function expression returned
=numbers= or =strings=, the type checker would have warned us that
return type doesn’t match the return type described in the
=SearchFunc= interface.

#+begin_src js
let mySearch: SearchFunc;
mySearch = function(src, sub) {
    let result = src.search(sub);
    return result > -1;
}
#+end_src

** Indexable Types
#+cindex:indexable types
#+cindex:types, indexable
#+cindex:interface for indexable type
#+cindex:index signature
Similarly to how we can use interfaces to describe function types, we
can also describe types that we can “index into” like ~a[10]~, or
~ageMap["daniel"]~.  Indexable types have an index signature that
describes the types we can use to index into the object, along with
the corresponding return types when indexing.  Let’s take an example:

#+begin_src js
interface StringArray {
    [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];
#+end_src

Above, we have a =StringArray= interface that has an index signature.
This index signature states that when a =StringArray= is indexed with
a =number=, it will return a =string=.

There are two types of supported index signatures: =string= and
=number=.  It is possible to support both types of indexers, /but the
type returned from a numeric indexer must be a subtype of the type
returned from the string indexer/.  This is because when indexing with
a =number=, JavaScript will actually convert that to a =string= before
indexing into an object.  That means that indexing with =100= (a
=number=) is the same thing as indexing with "100" (a =string=), so
the two need to be consistent.

#+begin_src js
class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

// Error: indexing with a numeric string might get you a completely separate type of Animal!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}
#+end_src

While string index signatures are a powerful way to describe the
“dictionary” pattern, /they also enforce that all properties match
their return type/.  This is because a string index declares that
=obj.property= is also available as =obj["property"]=.  In the
following example, =name= ’s type does not match the string index’s
type, and the type checker gives an error:

#+begin_src js
interface NumberDictionary {
    [index: string]: number;
    length: number;    // ok, length is a number
    name: string;      // error, the type of 'name' is not a subtype of the indexer
}
#+end_src

#+cindex:union
However, properties of different types are acceptable if the index
signature is a union of the property types:

#+begin_src js
interface NumberOrStringDictionary {
    [index: string]: number | string;
    length: number;    // ok, length is a number
    name: string;      // ok, name is a string
#+end_src

Finally, you can make index signatures =readonly= in order to prevent
assignment to their indices:

#+begin_src js
interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // error!
#+end_src

You can’t set ~myArray[2]~ because the index signature is =readonly=.

** Class Types
#+cindex:class types
#+cindex:interface, class
One of the most common uses of interfaces in languages like C# and
Java, that of explicitly enforcing that a class meets a particular
contract, is also possible in TypeScript.

#+begin_src js
interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date = new Date();
    constructor(h: number, m: number) { }
}
#+end_src

You can also describe methods in an interface that are implemented in
the class, as we do with ~setTime~ in the below example:

#+begin_src js
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date): void;
}

class Clock implements ClockInterface {
    currentTime: Date = new Date();
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
#+end_src

#+cindex:public interface
#+cindex:private interface
Interfaces describe the public side of the class, rather than both the
public and private side.  This prohibits you from using them to check
that a class also has particular types for the private side of the
class instance.

*** Static vs Instance
#+cindex:static side
#+cindex:instance side
#+cindex:construct signature
When working with classes and interfaces, it helps to keep in mind
that a class has two types: the type of the static side and the type
of the instance side.  You may notice that if you create an interface
with a construct signature and try to create a class that implements
this interface you get an error:

#+begin_src js
interface ClockConstructor {
    new (hour: number, minute: number);
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
#+end_src

This is because when a class implements an interface, only the
instance side of the class is checked.  Since the constructor sits in
the static side, it is not included in this check.

#+cindex:constructor function
Instead, you would need to work with the static side of the class
directly.  In this example, we define two interfaces,
=ClockConstructor= for the constructor and =ClockInterface= for the
instance methods.  Then, for convenience, we define a constructor
function ~createClock~ that creates instances of the type that is
passed to it:

#+caption:Interface for Constructor Function
#+name:interface-for-constructor-function
#+begin_src js -n
interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    tick(): void;
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("beep beep");
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("tick tock");
    }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
#+end_src

Because ~createClock~ ’s first parameter is of type
=ClockConstructor=, in ~createClock(AnalogClock, 7, 32)~, it checks
that =AnalogClock= has the correct constructor signature.

#+cindex:class expression
Another simple way is to use class expressions:

#+begin_src js
interface ClockConstructor {
  new (hour: number, minute: number);
}

interface ClockInterface {
  tick();
}

const Clock: ClockConstructor = class Clock implements ClockInterface {
  constructor(h: number, m: number) {}
  tick() {
      console.log("beep beep");
  }
}
#+end_src

** Extending Interfaces
#+cindex:interface, extend
Like classes, interfaces can extend each other.  This allows you to
copy the members of one interface into another, which gives you more
flexibility in how you separate your interfaces into reusable
components.

#+begin_src js
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = {} as Square;
square.color = "blue";
square.sideLength = 10;
#+end_src

An interface can extend multiple interfaces, creating a combination of
all of the interfaces.

#+begin_src js
interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = {} as Square;
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
#+end_src

** Hybrid Types
Interfaces can describe the rich types present in real world
JavaScript.  Because of JavaScript’s dynamic and flexible nature, you
may occasionally encounter an object that works as a combination of
some of the types described above.

One such example is an object that acts as both a function and an
object, with additional properties:

#+begin_src js
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = (function (start: number) { }) as Counter;
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
#+end_src

When interacting with 3rd-party JavaScript, you may need to use
patterns like the above to fully describe the shape of the type.

** Interfaces Extending Classes
When an interface type extends a class type it inherits the members of
the class but not their implementations.  It is as if the interface
had declared all of the members of the class without providing an
implementation.  Interfaces inherit even the private and protected
members of a base class.  This means that when you create an interface
that extends a class with private or protected members, that interface
type can only be implemented by that class or a subclass of it.

This is useful when you have a large inheritance hierarchy, but want
to specify that your code works with only subclasses that have certain
properties. The subclasses don’t have to be related besides inheriting
from the base class. For example:

#+begin_src js
class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class TextBox extends Control {
    select() { }
}

// Error: Property 'state' is missing in type 'Image'.
class Image implements SelectableControl {
    private state: any;
    select() { }
}

class Location {

}
#+end_src

In the above example, =SelectableControl= contains all of the members
of =Control=, including the =private= =state= property.  Since =state=
is a private member it is only possible for descendants of =Control=
to implement =SelectableControl=.  This is because only descendants of
=Control= will have a =state= =private= member that originates in the
same declaration, which is a requirement for private members to be
compatible.

Within the =Control= class it is possible to access the =state=
=private= member through an instance of =SelectableControl=.
Effectively, a =SelectableControl= acts like a =Control= that is known
to have a select method.  The =Button= and =TextBox= classes are
subtypes of =SelectableControl= (because they both inherit from
=Control= and have a =select= method), but the =Image= and =Location=
classes are not.

* Supplementary Programs
:PROPERTIES:
:appendix: t
:END:

** Tide for Emacs
=Tide= --- TypeScript Interactive Development Environment for Emacs

- https://github.com/ananthakumaran/tide

*** Tide Installation
- Install ~node.js v0.12.0~ or greater.

- Make sure ~tsconfig.json~ or ~jsconfig.json~ is present in the root
  folder of the project.

- =Tide= is available in [[http://melpa.org/#/tide][melpa]].  You can install =tide= via
  ~package-install M-x package-install [ret] tide~

*** Tide Configuration

#+begin_src emacs-lisp -n
(defun setup-tide-mode ()
  (interactive)
  (tide-setup)
  (flycheck-mode +1)
  (setq flycheck-check-syntax-automatically '(save mode-enabled))
  (eldoc-mode +1)
  (tide-hl-identifier-mode +1)
  ;; company is an optional dependency. You have to
  ;; install it separately via package-install
  ;; `M-x package-install [ret] company`
  (company-mode +1))

;; aligns annotation to the right hand side
(setq company-tooltip-align-annotations t)

;; formats the buffer before saving
(add-hook 'before-save-hook 'tide-format-before-save)

(add-hook 'typescript-mode-hook #'setup-tide-mode)
#+end_src

*** Tide Format Options

#+cindex:tide format options
#+cindex:format options, tide
Format options can be specified in multiple ways.

{{{heading(via elisp)}}}

#+findex:tide-format-options
#+name:tide-format-options
#+begin_src emacs-lisp
(setq tide-format-options 
      '(:insertSpaceAfterFunctionKeywordForAnonymousFunctions t
        :placeOpenBraceOnNewLineForFunctions nil))
#+end_src

{{{heading(via tsfmt.json)}}}

~tsfmt.json~ should be present in the root folder along with
~tsconfig.json~

#+pindex:@code{tsfmt.json}
#+name:tsfmt.json
#+begin_src js
{
  "indentSize": 4,
  "tabSize": 4,
  "insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces": false,
  "placeOpenBraceOnNewLineForFunctions": false,
  "placeOpenBraceOnNewLineForControlBlocks": false
}
#+end_src

** Makefile
:PROPERTIES:
:appendix: t
:END:
#+name:makefile
#+begin_src makefile -n :tangle makefile
SOURCE=TypeScript-Guide

info:	$(SOURCE).texi
	makeinfo $(SOURCE).texi

pdf:	$(SOURCE).texi
	pdftexi2dvi -q $(SOURCE).texi; \
	open $(SOURCE).pdf

clean-texi:
	-rm *.texi
clean-info:
	-rm *.info
clean-pdf:
	-rm *.pdf
clean-aux:
	-rm *.{aux,toc,log,cp,cps,pg,pgs,fn,fns}

clean: clean-texi clean-info clean-pdf clean-aux

phony:clean-texi clean-info clean-pdf clean-aux clean
#+end_src

* Concept Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:

* Program Index
:PROPERTIES:
:index:    pg
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:unnumbered: t
:index:    fn
:END:

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright {{{noindent}}}\copy 2019 {{{author}}} {{{theVersion}}}

* Macro Definitions                                                :noexport:

#+macro:theVersion Version {{{version}}} {{{date}}}
#+macro:noindent @@texinfo:@noindent @@
#+macro:heading @@texinfo:@heading@@ $1
#+macro:subheading @@texinfo:@subheading@@ $1
#+macro:command @@texinfo:@command{@@$1@@texinfo:}@@
#+macro:option @@texinfo:@option{@@$1@@texinfo:}@@

* Export Options                                                   :noexport:

** Texinfo Export Options

#+options: H:4
#+texinfo_filename:typescript-guide.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+subtitle:{{{theVersion}}}
#+subauthor:LOLH
#+texinfo_dir_category:Languages
#+texinfo_dir_title:TypeScript
#+texinfo_dir_desc:How to program using TypeScript
#+texinfo_printed_title:TypeScript Guide in Print

* Local Variables                                                  :noexport:
# Local Variables:
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
