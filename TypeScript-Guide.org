#+title:TypeScript Guide
#+author:Pinecone062
#+date:2019-11-26 10:45
#+macro:version 0.0.55

#+texinfo:@insertcopying

* About TypeScript
TypeScript is a superset of JavaScript that compiles to clean
JavaScript output.

- https://www.typescriptlang.org


TypeScript involves the following concepts:

- Types
- Functions
- Interfaces
- Classes
- Enums
- Modules
- Generic Types

** Source Code Repository
#+cindex:source
TypeScript is being developed on GitHub and is open source.

- https://github.com/Microsoft/TypeScript

** Gulp Installation
#+cindex:installation
#+cindex:updating

{{{heading(Adding TypeScript as a Global Installation)}}}

Installation is performed by Node:

#+name:global-installation
#+option: :results output :exports none
#+begin_src sh
yarn global add typescript
#+end_src

{{{heading(Adding TypeScript as a Local Development Dependency)}}}

#+name:local-installation
#+option: :results output :exports none
#+begin_src sh
yarn add --dev typescript
#+end_src

** Nightly Builds
- [[http://www.typescriptlang.org/docs/handbook/nightly-builds.html][Nightly Builds home]]
- The nightlies are available on [[https://www.myget.org/gallery/typescript-preview][www.myget.org]]

There are two packages:

- Microsoft.TypeScript.Compiler :: Tools only (~tsc.exe~, ~lib.d.ts~,
     etc.)

- Microsoft.TypeScript.MSBuild :: Tools as above, as well as MSBuild
     tasks and targets (Microsoft.TypeScript.targets,
     Microsoft.TypeScript.Default.props, etc.)


{{{heading(Using yarn)}}}

A nightly build from the TypeScript’s master branch is published by
midnight PST to NPM and NuGet.  Here is how you can get it and use it
with your tools:

: yarn global add typescript@next
: yarn add --dev typescript@next

* Configuration and Compilation
#+cindex:compilation
Where TypeScript is special is that instead of compiling straight to
bytecode, TypeScript compiles to… JavaScript code!  You then run that
JavaScript code like you normally would—in your browser, or with
NodeJS, or by hand with a paper and pen (for anyone reading this after
the machine uprising has begun).

** Compilation Basics
#+cindex:compiler
#+cindex:AST
#+cindex:abstract syntax tree
#+cindex:typechecker, typechecking
#+cindex:bytecode
After the TypeScript Compiler generates an AST for your program---but
before it emits code---it typechecks your code.  A typechecker is a
special program that verifies that your code is typesafe.  This
typechecking is the magic behind TypeScript.  It’s how TypeScript
makes sure that your program works as you expect, that there aren’t
obvious mistakes.

So if we include typechecking and JavaScript emission, the process of
compiling TypeScript now looks roughly like:

1. TypeScript source parsed into TypeScript AST
2. AST is checked by the typechecker
3. TypeScript AST is transpiled into JavaScript source
4. JavaScript source parsed into JavaScript AST
5. AST is compiled into JavaScript bytecode
6. Bytecode is evaluated by the JavaScript runtime


#+cindex:JavaScript runtime
Steps 1–3 are done by TSC, and steps 4–6 are done by the JavaScript
runtime that lives in your browser, NodeJS, or whatever JavaScript
engine you’re using.

In this process, steps 1–2 use your program’s types; step 3 does not.
That’s worth reiterating: when TSC compiles your code from TypeScript
to JavaScript, it won’t look at your types.  That means your program’s
types will never affect your program’s generated output, and are only
used for typechecking.  This feature makes it foolproof to play around
with, update, and improve your program’s types, without risking
breaking your application.

#+cindex:JavaScript engines
#+cindex:V8 engine
#+cindex:SpiderMonkey engine
#+cindex:JSCore
#+cindex:Chakra
JavaScript compilers and runtimes tend to be smushed into a single
program called an engine; as a programmer, this is what you’ll
normally interact with. It’s how V8 (the engine powering NodeJS,
Chrome, and Opera), SpiderMonkey (Firefox), JSCore (Safari), and
Chakra (Edge) work, and it’s what gives JavaScript the appearance of
being an interpreted language.

** The Type System
#+cindex:type system
#+cindex:typechecker
A type system is a set set of rules a typechecker uses to assign types
to your program.  There are generally two kinds of type systems: type
systems in which you have to tell the compiler what type everything is
with explicit syntax, and type systems that infer the types of things
for you automatically. Both approaches have trade-offs.  TypeScript is
inspired by both kinds of type systems: you can explicitly annotate
your types, or you can let TypeScript infer most of them for you.

#+cindex:annotation
#+cindex:type annotation
#+cindex:inference
#+cindex:type inference
To explicitly signal to TypeScript what your types are, use
annotations.  Annotations take the form =value: type= and tell the
typechecker that the =value= has the =type=.  If you want TypeScript
to infer your types for you, just leave them off and let TypeScript
get to work.  In general, it is good style to let TypeScript infer as
many types as it can for you, keeping explicitly typed code to a
minimum.

{{{heading(Gradually Typed System)}}}

#+cindex:gradual typing
#+cindex:gradually typed system
TypeScript is a gradually typed language.  That means that TypeScript
works best when it knows the types of everything in your program at
compile time, but it doesn’t have to know every type in order to
compile your program.  Even in an untyped program TypeScript can infer
some types for you and catch some mistakes, but without knowing the
types for everything, it will let a lot of mistakes slip through to
your users.

This gradual typing is really useful for migrating legacy codebases
from untyped JavaScript to typed TypeScript (more on that in
“Gradually Migrating from JavaScript to TypeScript”), but unless
you’re in the middle of migrating your codebase, you should aim for
100% type coverage.

{{{heading(Weakly Typed System)}}}

#+cindex:weakly typed system
JavaScript is weakly typed, meaning if you do something invalid like
add a number and an array (like we did in Chapter 1), it will apply a
bunch of rules to figure out what you really meant so it can do the
best it can with what you gave it.  If you do something that doesn’t
seem right, TypeScript complains, and if you’re explicit about your
intentions, TypeScript gets out of your way.

{{{heading(Many Errors are Found through Static Analysis)}}}

#+cindex:compile time
#+cindex:static analysis
TypeScript typechecks your code at compile time (remember step 2 in
the list at the beginning of this chapter?), so you don’t need to
actually run your code to see the Error from the previous example.
TypeScript statically analyzes your code for errors like these, and
shows them to you before you run it.  If your code doesn’t compile,
that’s a really good sign that you made a mistake and you should fix
it before you try to run the code.

#+cindex:syntax errors
#+cindex:type-related errors
TypeScript throws both syntax-related errors and type-related errors
at compile time.  In practice, that means those kinds of errors will
show up in your code editor, right as you type---it’s an amazing
experience if you’ve never worked with an incrementally compiled
statically typed language before.  That said, there are lots of errors
that TypeScript can’t catch for you at compile time---things like
stack overflows, broken network connections, and malformed user
inputs—that will still result in runtime exceptions.  What TypeScript
does is make compile-time errors out of most errors that would have
otherwise been runtime errors in a pure JavaScript world.

** Project Structure
In a TypeScript project, it's best to have separate source and
distributable files.  TypeScript (~.ts~) files live in your ~src~
folder and after compilation are output as JavaScript (~.js~) in the
~dist~ folder.  The ~test~ and ~views~ folders remain top level as
expected.

The full folder structure of a sample app is explained below:

- dist :: Contains the distributable (or output) from your TypeScript
          build. This is the code you ship
- node_modules :: Contains all your npm dependencies
- src :: Contains your source code that will be compiled to the dist
         dir
- src/config :: Passport authentication strategies and login
                middleware. Add other complex config code here
- src/controllers :: Controllers define functions that respond to
     various http requests
- src/models :: Models define Mongoose schemas that will be used in
                storing and retrieving data from MongoDB
- src/public :: Static assets that will be used client side
- src/types :: Holds .d.ts files not found on DefinitelyTyped. Covered
               more in this [[https://github.com/Microsoft/TypeScript-Node-Starter#type-definition-dts-files][section]]
- src/server.ts :: Entry point to your express app
- test :: Contains your tests. Separate from source because there is a
          different build process.
- views :: views define how your app renders on the client.
- .env :: API keys, tokens, passwords, database URI. Clone this, but
          don't check it in to public repos.
- .travis.yml :: Used to configure Travis CI build
- .copyStaticAssets.ts :: Build script that copies images, fonts, and
     JS libs to the dist folder
- jest.config.js :: Used to configure Jest running tests written in
                    TypeScript
- package.json :: File that contains npm dependencies as well as build
                  scripts
- tsconfig.json :: Config settings for compiling server code written
                   in TypeScript
- tsconfig.tests.json :: Config settings for compiling tests written
     in TypeScript
- .eslintrc :: Config settings for ESLint code style checking
- .eslintignore :: Config settings for paths to exclude from linting

** The ~tsconfig~ File
Every TypeScript project should include a file called ~tsconfig.json~
in its root directory.  This tsconfig.json is where TypeScript
projects define things like which files should be compiled, which
directory to compile them to, and which version of JavaScript to emit.

#+cindex:schema, @file{tsconfig.json}
#+cindex:@file{tsconfig.json} schema
Schema for the ~tsconfig.json~ file can be found at:
- http://json.schemastore.org/tsconfig


#+cindex:@file{tsconfig.json} file
#+cindex: configuration
#+cindex:TypeScript project
#+cindex:project, TypeScript
#+cindex:root files, TypeScript project
#+cindex:compiler options
The presence of a ~tsconfig.json~ file in a directory indicates that
the directory is the root of a TypeScript project.

A ~tsconfig.json~ file specifies:

- the root files
- the compiler options


{{{noindent}}}required to compile the project.

A ~tsconfig.json~ file is permitted to be completely empty, which
compiles all files included by default with the default compiler
options.  Compiler options specified on the command line override
those specified in the ~tsconfig.json~ file.

*** The =compilerOptions= Property
#+cindex:@code{compilerOptions} property
#+cindex:default compiler options
#+cindex:compiler options, defaults
The =compilerOptions= property can be omitted, in which case the
compiler’s defaults are used.

**** List of Compiler Options
For a complete list of compiler options, see:
- http://www.typescriptlang.org/docs/handbook/compiler-options.html


#+cindex:compiler options, list
#+attr_texinfo: :indic code
- --allowJs :: boolean =false=
- --allowSyntheticDefaultImports :: boolean module === "system" or
     --esModuleInterop
- --allowUmdGlobalAccess :: boolean =false=
- --allowUnreachableCode :: boolean =false=
- --allowUnusedLabels :: boolean =false=
- --alwaysStrict :: boolean false
- --baseUrl :: string; See [[http://www.typescriptlang.org/docs/handbook/module-resolution.html#base-url][Module Resolution documentation]]
- --build -b :: boolean =false=
- --charset :: string "utf8"
- --checkJs :: boolean =false=
- --composite :: boolean =true=
- --declaration -d :: boolean =false=
- --declarationDir :: string
- --declarationMap :: boolean =false=
- --diagnostics :: boolean =false=
- --disableSizeLimit :: boolean =false=
- --downlevelIteration :: boolean =false=
- --emitBOM :: boolean =false=
- --emitDeclarationOnly :: boolean =false=
- --emitDecoratorMetadata :: boolean =false=
- --esModuleInterop :: boolean =false=
- --experimentalDecorators :: boolean =false=
- --extendedDiagnostics :: boolean =false=
- --forceConsistentCasingInFileNames :: boolean =false=
- --help -h :: empty
- --importHelpers :: boolean =false=
- --incremental :: boolean =true= if composite; =false= otherwise
- --inlineSourceMap :: boolean =false=
- --inlineSources :: boolean =false=
- --init :: empty
- --isolatedModules :: boolean =false=
- --jsx :: string "preserve" | "react" | "react-native"
- --jsxFactory :: string "React.createElement" | "h"
- --keyofStringsOnly :: boolean =false=
- --lib :: string[] [default list of libraries are injected]
- --listEmittedFiles :: boolean =false=
- --listFiles :: boolean =false=
- --locale :: string "en"
- --mapRoot :: string
- --maxNodeModuleJsDepth :: number 0
- --module -m :: string target === "ES3" or "ES5" ? "CommonJS" : "ES6"
- --moduleResolution :: string module === "AMD" or "System" or "ES6" ?
     "Classic" : "Node"
- --newLine :: string "lf"
- --noEmit :: boolean =false=
- --noEmitHelpers :: boolean =false=
- --noEmitOnError :: boolean =false=
- --noErrorTruncation :: boolean =false=
- --noFallthroughCasesInSwitch :: boolean =false=
- --noImplicitAny :: boolean =false=
- --noImplicitReturns :: boolean =false=
- --noImplicitThis :: boolean =false=
- --noImplicitUseStrict :: boolean =false=
- --noLib :: boolean =false=
- --noResolve :: boolean =false=
- --noStrictGenericChecks :: boolean =false=
- --noUnusedLocals :: boolean =false=
- --noUnusedParameters :: boolean =false=
- --outDir :: string
- --outFile :: string
- paths :: Object
- --preserveConstEnums :: boolean =false=
- --preserveSymlinks :: boolean =false=
- --preserveWatchOutput :: boolean =false=
- --pretty :: boolean =true= unless piping or redirecting
- --project -p :: string
- --reactNamespace :: deprecated; use {{{option(--jsxFactory)}}}
- --removeComments :: boolean =false=
- --resolveJsonModule :: boolean =false=
- --rootDir :: string [computed from input files]
- rootDirs :: string[]
- --showConfig :: boolean =false=
- --skipDefaultLibCheck :: boolean =false=
- --skipLibCheck :: boolean =false=
- --sourceMap :: boolean =false=
- --sourceRoot :: string
- --strict :: boolean =false=
- --strictBindCallApply :: boolean =false=
- --strictFunctionTypes :: boolean =false=
- --strictPropertyInitialization :: boolean =false=
- --strictNullChecks :: boolean =false=
- --suppressExcessPropertyErrors :: boolean =false=
- --suppressImplicitAnyIndexErrors :: boolean =false=
- --target -t :: string "ES3"
- --traceResolution :: boolean =false=
- --tsBuildInfoFile :: boolean =false=
- --types :: string[]
- --typeRoots :: string[]
- --version -v :: [empty]
- --watch -w :: [empty]

*** The =files= and =include= and =exclude= Properties

#+cindex:@code{files} property
#+cindex:@code{include} property
#+cindex:@code{exclude} property
Files and can included or excluded from a project by using a
combination of the =files=, the =include=, and the =exclude=
properties, and the =outDir= compiler option in the ~tsconfig.json~
file.

{{{subheading(Include Defaults)}}}

If the =files= and =include= properties are both left unspecified, the
compiler defaults to including all TypeScript files in the containing
directory and subdirectories except those excluded using the =exclude=
property.  (See below for default extensions.)  JS files (see below)
are also included if =allowJs= is set to =true=.

{{{subheading(Including Files)}}}

If the =files= and/or =include= properties are specified, the compiler
will instead include the union of the files included by those two
properties.

Any files that are referenced via the =files= or =include= properties
are included.  Files included using =include= can be filtered using
the =exclude= property, but files included explicitly using the
=files= property are always included regardless of =exclude=.

Files in the directory specified using the =outDir= compiler option
are excluded as long as =exclude= property is /not/ specified.

If a file ~B.ts~ is referenced by another file ~A.ts~, then ~B.ts~
cannot be excluded unless the referencing file ~A.ts~ is also
specified in the =exclude= list.  The compiler does not include files
that can be possible outputs; e.g. if the input includes ~index.ts~,
then ~index.d.ts~ and ~index.js~ are excluded.

**** The =files= Property
#+cindex:@code{files} property
The =files= property takes a list of relative or absolute file paths.

**** The =include= and =exclude= Properties
#+cindex:@code{include} property
#+cindex:@code{exclude} property
#+cindex:glob patterns
#+cindex:wildcards, glob
The =include= and =exclude= properties take a list of glob-like file
patterns.  The supported glob wildcards are:

- =*= :: matches zero or more characters (excluding directory
         separators)

         If a segment of a glob pattern includes only =*= or =.*=,
         then only files with supported extensions are included.
         Supported extensions include:

  - =.ts=

  - =.tsx=

  - =.d.ts=

    If =allowJs= is set to =true=:

  - =.js=

  - =.jsx=

- =?= :: matches any one character (excluding directory separators)

- =**/= :: recursively matches any subdirectory


#+cindex:@file{node_modules}
#+cindex:@file{bower_components}
#+cindex:@file{jspm_packages}
#+cindex:@code{outDir} property
=exclude= by default excludes the following directories:

- ~node_modules~
- ~bower_components~
- ~jspm_packages~
- =outDir=

**** Including and Excluding Types Packages

#+cindex:types package
#+cindex:@file{index.d.ts} file
#+cindex:@code{types} field
A /types package/ is a folder with a file called ~index.d.ts~ or a
folder with a ~package.json~ that has a =types= field.

{{{subheading(Include @types Packages)}}}

#+cindex:@code{@@types} packages
By default all visible =@@types= packages are included in your
compilation.  Packages in ~node_modules/@types~ of any enclosing
folder are considered visible.  That means packages within the
following directores are visible:

- ~./node_modules/@types/~
- ~../node_modules/@types/~
- ~../../node_modules/@types/~


Automatic inclusion is only important if you’re using files with
global declarations (as opposed to files declared as modules).  If you
use an =import "foo"= statement, for instance, TypeScript may still
look through ~node_modules~ and ~node_modules/@types~ folders to find
the ~foo~ package.

{{{subheading(Exclude @types Packages)}}}

Specify ="types": []= to disable automatic inclusion of =@types=
packages.

{{{heading(typeRoots)}}}

If =typeRoots= is specified, only packages under =typeRoots= will be
included.  This config file will include all packages under
~./typings~, and no packages from ~./node_modules/@types~.

#+begin_src js
{
   "compilerOptions": {
       "typeRoots" : ["./typings"]
   }
}
#+end_src

{{{heading(types)}}}

If types is specified, only packages listed will be included.  This
~tsconfig.json~ file will only include ~./node_modules/@types/node~,
~./node_modules/@types/lodash~ and ~./node_modules/@types/express~.
Other packages under ~node_modules/@types/*~ will not be included.

#+begin_src js
{
   "compilerOptions": {
       "types" : ["node", "lodash", "express"]
   }
}
#+end_src

*** Example tsconfig.json Files

{{{heading(Standard Options)}}}

#+begin_src js
{
  "compilerOptions": {
    "lib": ["es2015"],
    "module": "commonjs",
    "outDir": "dist",
    "sourceMap": true,
    "strict": true,
    "target": "es2015"
  },
  "include": [
    "src"
  ]
}
#+end_src

- include :: Which folders should TSC look in to find your TypeScript
             files?
- lib :: Which APIs should TSC assume exist in the environment you’ll
         be running your code in?  This includes things like ES5’s
         ~Function.prototype.bind~, ES2015’s ~Object.assign~, and the
         DOM’s ~document.querySelector~.
- module :: Which module system should TSC compile your code to
            (CommonJS, SystemJS, ES2015, etc.)?
- outDir :: Which folder should TSC put your generated JavaScript code
            in?
- strict :: Be as strict as possible when checking for invalid
            code.  This option enforces that all of your code is
            properly typed.
- target :: Which JavaScript version should TSC compile your code to
            (ES3, ES5, ES2015, ES2016, etc.)?


Note that while using a ~tsconfig.json~ file to configure TSC is handy
because it lets us check that configuration into source control, you
can set most of TSC’s options from the command line too.  Run
=./node_modules/.bin/tsc --help= for a list of available command-line
options.

{{{heading("Files" Property)}}}

#+caption:tsconfig.json using the "files" property
#+name:tsconfig.json-using-files-property
#+begin_src js -n
{
    "compilerOptions": {
        "module": "commonjs",
        "noImplicitAny": true,
        "removeComments": true,
        "preserveConstEnums": true,
        "sourceMap": true
    },
    "files": [
        "core.ts",
        "sys.ts",
        "types.ts",
        "scanner.ts",
        "parser.ts",
        "utilities.ts",
        "binder.ts",
        "checker.ts",
        "emitter.ts",
        "program.ts",
        "commandLineParser.ts",
        "tsc.ts",
        "diagnosticInformationMap.generated.ts"
    ]
}
#+end_src

{{{heading("Include" and "Exclude" Properties)}}}

#+caption:tsconfig using the "include" and "exclude" properties
#+name:tsconfig.json-using-include-and-exclude-properties
#+begin_src js -n
{
    "compilerOptions": {
        "module": "system",
        "noImplicitAny": true,
        "removeComments": true,
        "preserveConstEnums": true,
        "outFile": "../../built/local/tsc.js",
        "sourceMap": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.spec.ts"
    ]
}
#+end_src
*** Extending Configuration
A ~tsconfig.json~ file can inherit configurations from another file
using the =extends= property.  The =extends= property is a top-level
property, along with =compilerOptions=, =files=, =includes=, and
=excludes.=.  The =extends= value is a string containing a path to
another configuration file to inherit from.

The configuration from the base file is loaded first, then overridden
by those in the inheriting config file.  If a circularity is
encountered, an error is reported.  All relative paths found in the
configuration file will be resolved relative to the configuration file
they originated in.

**** Example ~tsconfig.json~ Using =extends=
#+name:configs-base.json
#+begin_src js
{
  "compilerOptions": {
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
#+end_src

#+name:tsconfig.json-using-extends
#+begin_src js
{
  "extends": "./configs/base",
  "files": [
    "main.ts",
    "supplemental.ts"
  ]
}
#+end_src

#+name:tsconfig-nostrictnull
#+begin_src js
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "strictNullChecks": false
  }
}
#+end_src

*** CompileOnSave
Setting a top-level property =compileOnSave= signals to the IDE to
generate all files for a given ~tsconfig.json~ upon saving.  This
feature is currently supported in Visual Studio 2015 with TypeScript
1.8.4 and above, and atom-typescript plugin.

#+name:tsconfig.json-compile-on-save
#+begin_src js
{
   "compileOnSave": true,
   "compilerOptions": {
       "noImplicitAny" : true
   }
}
#+end_src

** The ~tslint.json~ File
#+cindex:@file{tslint.json} file
Your project should also have a ~tslint.json~ file containing your
TSLint configuration, codifying whatever stylistic conventions you
want for your code (tabs versus spaces, etc.).

The following command will generate a ~tslint.json~ file with a
default TSLint configuration:

#+tslint.json-init
#+begin_src sh
./node_modules/.bin/tslint --init
#+end_src

** Creating a TypeScript Project

{{{heading(Install NodeJS)}}}

#+cindex:@command{tsc}
#+cindex:NodeJS
#+cindex:@command{npm}
#+cindex:package manager
#+cindex:TSLint
#+cindex:linter
~tsc~ is itself a command-line application written in TypeScript,
which means you need NodeJS to run it.  Follow the instructions on the
official NodeJS website to get NodeJS up and running on your machine.
NodeJS comes with ~npm~, a package manager that you will use to manage
your project’s dependencies and orchestrate your build.  We’ll start
by using it to install ~tsc~ and TSLint (a linter for TypeScript).

{{{heading(Create a TypeScript Project)}}}

#+cindex:@code{npm} project
#+cindex:TypeScript project
#+cindex:project
#+cindex:install TypeScript
#+cindex:type declarations
Start by opening your terminal and creating a new folder, then
initializing a new ~npm~ project in it:

#+begin_src sh
# Create a new folder
mkdir chapter-2
cd chapter-2

# Initialize a new NPM project (follow the prompts)
npm init

# Install TSC, TSLint, and type declarations for NodeJS
npm install --save-dev typescript tslint @types/node”
#+end_src

** Configuring a TypeScript Project

#+cindex:compilation
#+cindex:@file{tsconfig.json}
#+cindex:root directory
Every TypeScript project should include a file called
{{{file(tsconfig.json)}}} in its root directory.  This
{{{file(tsconfig.json)}}} is where TypeScript projects define things
like which files should be compiled, which directory to compile them
to, and which version of JavaScript to emit.

Create a new file called {{{file(tsconfig.json)}}} in your root folder
(=touch tsconfig.json=), then pop it open in your code editor and give
it the following contents:

#+caption: Simple {{{file(tsconfig.json)}}} File
#+name:simple-tsconfig.json
#+begin_src js
{
  "compilerOptions": {
    "lib": ["es2015"],
    "module": "commonjs",
    "outDir": "dist",
    "sourceMap": true,
    "strict": true,
    "target": "es2015"
  },
  "include": [
    "src"
  ]
}
#+end_src

A project is compiled:

{{{heading(Using tsconfig.json)}}}

- By invoking {{{command(tsc)}}} with no input files, in which case
  the compiler searches for the ~tsconfig.json~ file starting in the
  current directory and continuing up the parent directory chain.

- By invoking {{{command(tsc)}}} with no input files and an
  {{{option(--project)}}} (or just {{{option(-p)}}}) command line
  option that specifies the path of a directory containing a
  ~tsconfig.json~ file, or a path to a valid ~.json~ file containing
  the configurations.


{{{heading(With Input Files)}}}

- By invoking {{{command(tsc)}}} with input files on the command line,
  in which case a ~tsconfig.json~ files are ignored.

** Project References
- http://www.typescriptlang.org/docs/handbook/project-references.html


#+cindex:project reference
/Project references/ are a new feature in TypeScript 3.0 that allow
you to structure your TypeScript programs into smaller pieces.  By
doing this, you can:

- greatly improve build times
- enforce logical separation between components
- organize your code in new and better ways


There is also a new mode for {{{command(tsc)}}}, the
{{{option(--build)}}} flag that works hand in hand with project
references to enable faster TypeScript builds.

*** The =references= Property
~tsconfig.json~ files have a new top-level property, =references=.
It’s an array of objects that specifies projects to reference:

#+name:tsconfig-with-references
#+begin_src js
{
    "compilerOptions": {
        // The usual
    },
    "references": [
        { "path": "../src" }
    ]
}
#+end_src

The =path= property of each reference can point to a directory
containing a ~tsconfig.json~ file, or to the config file itself (which
may have any name).

When you reference a project, new things happen:

- Importing modules from a referenced project will instead load its
  output declaration file (~.d.ts~)

- If the referenced project produces an =outFile=, the output file
  ~.d.ts~ file’s declarations will be visible in this project

- Build mode (see below) will automatically build the referenced
  project if needed


By separating into multiple projects, you can greatly improve the
speed of typechecking and compiling, reduce memory usage when using an
editor, and improve enforcement of the logical groupings of your
program

*** The =composite= Property
Referenced projects must have the new =composite= setting enabled.
This setting is needed to ensure TypeScript can quickly determine
where to find the outputs of the referenced project.

Enabling the composite flag changes a few things:

- The =rootDir= setting, if not explicitly set, defaults to the
  directory containing the ~tsconfig~ file

- All implementation files must be matched by an =include= pattern or
  listed in the files array.  If this constraint is violated, ~tsc~
  will inform you which files weren’t specified

- =declaration= must be turned on

*** The =prepend= Property
You can also enable prepending the output of a dependency using the
=prepend= option in a reference:

#+name:tsconfig-using-prepend
#+begin_src js
"references": [
       { "path": "../utils", "prepend": true }
   ]
#+end_src

Prepending a project will include the project’s output above the
output of the current project.  This works for both ~.js~ files and
~.d.ts~ files, and source map files will also be emitted correctly.

*** Build Mode
To preserve compatibility with existing build workflows, ~tsc~ will
not automatically build dependencies unless invoked with the
{{{option(--build)}}} switch.

A long-awaited feature is /smart incremental builds/ for TypeScript
projects.  In 3.0 you can use the {{{option(--build)}}} flag with
~tsc~.  This is effectively a new entry point for ~tsc~ that behaves
more like a build orchestrator than a simple compiler.

Running ~tsc --build~ (~tsc -b~ for short) will do the following:

- Find all referenced projects

- Detect if they are up-to-date

- Build out-of-date projects in the correct order


You can provide ~tsc -b~ with multiple config file paths (e.g. ~tsc -b
src test~).  Specifying the config file name itself is unnecessary if
it’s named ~tsconfig.json~.

You can specify any number of config files:

#+begin_example
> tsc -b                            # Use the tsconfig.json in the current directory
> tsc -b src                        # Use src/tsconfig.json
> tsc -b foo/prd.tsconfig.json bar  # Use foo/prd.tsconfig.json and bar/tsconfig.json
#+end_example

There are also some flags specific to tsc -b:

#+attr_texinfo: :indic option
- --verbose :: Prints out verbose logging to explain what’s going on
               (may be combined with any other flag)

- --dry :: Shows what would be done but doesn’t actually build anything

- --clean :: Deletes the outputs of the specified projects (may be
             combined with {{{option(--dry)}}})

- --force :: Act as if all projects are out of date

- --watch :: Watch mode (may not be combined with any flag except
             {{{option(--verbose)}}})

** Integrating with Build Tools

#+cindex:build tools
*** Babel
#+cindex:babel
{{{heading(Install Babel)}}}

: npm install @babel/cli @babel/core @babel/preset-typescript --save-dev

#+cindex:@file{.babelrc}
{{{heading(.babelrc File)}}}

#+begin_src js
{
  "presets": ["@babel/preset-typescript"]
}
#+end_src

{{{heading(Using Command Line Interface)}}}

: ./node_modules/.bin/babel --out-file bundle.js src/index.ts

{{{heading(package.json File)}}}

#+begin_src js
{
  "scripts": {
    "build": "babel --out-file bundle.js main.ts"
  },
}
#+end_src

{{{heading(Execute Babel from the command line)}}}

: npm run build
*** Browserify
{{{heading(Install Browserify)}}}

: npm install tsify

See:
- [[https://github.com/TypeStrong/tsify][tsify---Browsify plugin for TypeScript]]

{{{heading(Using Command Line Interface)}}}

: $ browserify main.ts -p [ tsify --noImplicitAny ] > bundle.js

{{{heading(Using API)}}}

#+begin_src js
var browserify = require("browserify");
var tsify = require("tsify");

browserify()
    .add("main.ts")
    .plugin("tsify", { noImplicitAny: true })
    .bundle()
    .pipe(process.stdout);
#+end_src
*** Duo
~due-typescript~: The typescript compiler plugin for ~duo~

See:
- [[https://github.com/frankwallis/duo-typescript][due-typescript]]
*** GruntJS
**** grunt-ts
~grunt-ts~ : TypeScript Compilation Task for GruntJS

{{{heading(Install grunt-ts)}}}

: npm install grunt-ts

See:
- [[https://github.com/TypeStrong/grunt-ts][grunt-ts]]

{{{heading(Basic Gruntfile.js File)}}}

#+begin_src js
module.exports = function(grunt) {
    grunt.initConfig({
        ts: {
            default : {
                src: ["**/*.ts", "!node_modules/**/*.ts"]
            }
        }
    });
    grunt.loadNpmTasks("grunt-ts");
    grunt.registerTask("default", ["ts"]);
};
#+end_src

**** GruntJS for TypeScript
- from /TypeScript 3.0 Quick Start Quide/, by Patrick Desjardins
  (\copy 2018)


Install the Grunt CLI tool globally:
: yarn add global grunt-cli

{{{heading(Install Development Dependencies)}}}

Install TypeScript (~typescript~), Grunt (~grunt~) and ~grunt-ts~, a Grunt TypeScript plugin, in
your project as development dependencies:

#+caption:Install TypeScript, GruntJS, and Grunt-TS as Dev Dependencies
#+name:install-typescript-grunt-grunt-ts-as-dev-deps
#+begin_src sh :dir examples/test-grunt :results output :exports results
yarn init -yp
yarn add --dev typescript grunt grunt-ts
#+end_src

{{{heading(Install a Gruntfile.js)}}}

Now configure Grunt to use a TypeScript plugin.  Create a
~Gruntfile.js~ in the project's root directory.  Limit the TypeScript
options placed into the ~Gruntfile.js~ and instead leverage the
TypeScript configuration file.

A minimilist Grunt configuration with the sole purpose of compiling
TypeScript into JavaScript would look like this:

#+caption:Minimilist Grunt Configuration
#+name:minimal-grunt-config
#+header: :mkdirp yes
#+begin_src js -n :tangle examples/test-grunt/Gruntfile.js
  module.exports = function(grunt) {
   grunt.initConfig({
     ts: {
      default : {
       tsconfig: './tsconfig.json'
      }
     }
   });
   grunt.loadNpmTasks("grunt-ts");
   grunt.registerTask("default", ["ts"]);
  };
#+end_src

The Grunt configuration creates a default task that executes a custom
=ts= task that links to the ~tsconfig.json~ file, which is the default
TypeScript configuration file.

{{{heading(Install a tsconfig.json File)}}}

A minimilist ~tsconfig.json~ file can look like:

#+caption:Minimilist TS Config File
#+name:minimilist-tsconfig
#+header: :mkdirp yes
#+begin_src js -n :tangle examples/test-grunt/tsconfig.json
  {
   "compilerOptions": {
     "rootDir": "src",
     "outDir": "build"
   }
  }
#+end_src

This takes every TypeScript file with the extension ~.ts~ and compiles
them, placing them in the ~build~ folder.

{{{heading(Test Grunt Compilation)}}}

To test the configuration, create a simple ~index.ts~ file in a ~src/~
folder at the root of the project.  You can type
~console.log('test')~.  After, run ~grunt~ in a command line at the
root of your project as well.  This will create a build folder with an
~index.js~ file containing the same line of code.  It will also create
the ~js.map~ file that will let you debug in your browser directly in
TypeScript's code.

#+caption:Test File for Grunt Configuration
#+name:test-file-for-grunt-configuration
#+header: :mkdirp yes
#+begin_src js -n :tangle examples/test-grunt/src/test-grunt.ts
console.log('testing Grunt configuration');
#+end_src

#+caption:Test Grunt Configuration
#+name:test-grunt-configuration
#+header: :dir examples/test-grunt
#+begin_src sh :results output :exports both
grunt
tree -I node_modules
#+end_src

*** Gulp
- [[https://www.npmjs.com/package/gulp][gulp]] :: Gulp is a toolkit that helps you automate painful or
     time-consuming tasks in your development workflow.

- [[https://www.npmjs.com/package/gulp-cli][gulp-cli]] :: Command Line Utility for Gulp
  : $ gulp [flags] <task> <task>...

- [[https://github.com/ivogabe/gulp-typescript][gulp-typescript]] :: A gulp plugin for handling TypeScript compilation
     workflow.  The plugin exposes TypeScript's compiler options to
     gulp using TypeScript API.

{{{heading(Install typescript, gulp, and gulp-typescript)}}}

#+caption:Gulp and Tooling Installation
#+name:gulp-tooling-installation
#+begin_src sh :results silent :exports both :dir examples/test-gulp
yarn init -yp
yarn add --dev typescript gulp gulp-typescript
#+end_src

{{{heading(Basic gulpfile.js)}}}

Create a ~Gulpfile.js~ in the root of the project.

#+caption:A Test Gulpfile
#+name:test-gulpfile.js
#+header: :mkdirp yes
#+begin_src js :tangle examples/test-gulp/Gulpfile.js
var gulp = require("gulp");
var ts = require("gulp-typescript");

exports.default = function () {
    var tsResult = gulp.src("src/*.ts")
        .pipe(ts({
              noImplicitAny: true,
              out: "output.js"
        }));
    return tsResult.js.pipe(gulp.dest("build/local"));
};
#+end_src

#+caption:Basic File to Test Gulp
#+name:basic-file-to-test-gulp
#+header: :mkdirp yes
#+begin_src js -n :tangle examples/test-gulp/src/basic.ts
console.log('Testing gulp');
#+end_src

#+caption:Test Gulp
#+name:test-gulp
#+begin_src sh :results output :exports both :dir examples/test-gulp
gulp
#+end_src

#+begin_src sh :results output :exports results
tree -I node_modules
#+end_src

**** TypeScript Node and Gulp---ts-node
- [[https://www.npmjs.com/package/ts-node][ts-node]] :: TypeScript execution and REPL for node.js, with source
     map support.


By installing the ~ts-node~ module, you can compile TypeScript into
JavaScript with Gulp.  Install ~ts-node~, ~@types/node~[fn:1], and
~typescript~ locally.

#+caption:TypeScript Node and Gulp Installation
#+name:typescript-node-gulp-installation
#+header: :dir examples/test-tsnode
#+begin_src sh :results output :exports both
yarn init -yp
yarn add --dev gulp ts-node typescript @types/node
#+end_src

Create a simple Gulpfile.  This Gulpfile simply pipes TypeScript files
through ~gulp~ into the ~build~ directory.

#+caption:TypeScript Node Gulpfile
#+name:typescript-node-gulpfile
#+header: :mkdirp yes
#+begin_src js -n :tangle examples/test-tsnode/Gulpfile.ts
var gulp = require("gulp");

exports.default = function () {
  return gulp.src("src/*.ts").pipe(gulp.dest("build/local"));
};
#+end_src

This is the TypeScript file that needs to be transpiled.

#+caption:Basic TypeScript Node File
#+name:basic-typescript-node-file
#+header: :mkdirp yes
#+begin_src js -n :tangle examples/test-tsnode/src/basic.ts
console.log('Hello TypeScript Node');
#+end_src

Run Gulp with ~gulp~.

#+caption:Run Gulp Under TypeScript Node
#+name:run-gulp-under-typescript-node
#+header: :dir examples/test-tsnode
#+begin_src sh :results output :exports both
gulp
#+end_src

**** Using Gulp to Compile TypeScript
- from /TypeScript 3.0 Quick Start Quide/, by Patrick Desjardins
  (\copy 2018)


~gulp.js~ is a build tool in JavaScript built on node streams.  These
streams facilitate the connection of file operations through
pipelines.  ~gulp~ reads the file system and pipes the data at hand
from one single-purposed plugin to another through the ~.pipe()~
operator, doing one task at a time.  ~gulp~ requires knowledge of
JavaScript and coding to define its tasks.  ~gulp~ is a build system
which means apart from running tasks, it is also capable of copying
files from one location to another, compiling, deploying, creating
notifications, unit testing, linting, etc.

Grunt runs tasks by transforming files and saves as new ones in
temporary folders and the output of one task is taken as input for
another and so on until the output reaches the destination
folder. This involves a lot of I/O calls and creation of many
temporary files.

Whereas ~gulp~ streams through the file system and does not require
any of these temporary locations decreasing the number of I/O calls
thus, improving performance.

Grunt uses configuration files to perform tasks whereas ~gulp~
requires its build file to be coded.  In Grunt, each plugin needs to
be configured to match its input location to the previous plugin’s
output. In ~gulp~, the plugins are automatically pipe-lined
*** Jspm
- [[https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm][jspm]]
*** Webpack
Webpack's main purpose is to /bundle/, but it can do many sequential
steps, such as compiling TypeScript.  Webpack has two loaders for
TypeScript:

- [[https://www.npmjs.com/package/ts-loader][ts-loader]] :: TypeScript loader for webpack

- [[https://www.npmjs.com/package/awesome-typescript-loader][awesome-typescript-loader]] :: TypeScript loader for webpack


For a description of some of the differences between the two, see
- https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader


{{{heading(Install Webpack)}}}

: yarn add --dev webpack wepback-cli

{{{heading(Install typescript and ts-loader)}}}

: yarn add --dev typescript ts-loader

{{{heading(Basic webpack.config.js when using Webpack 2)}}}

Once the tools are installed, configure Webpack to bundle the
JavaScript produced by the ~webpack~ TypeScript loader.
~webpack.config.js~ is needed at the root of your project, and the
=entry= property must be defined.  This property must point to the
TypeScript file.  The output is specified by the =output= property.
Webpack requires that you specify the extension to be analyzed under
the properties =resolve:extensions=.  For TypeScript, this would be
~.ts~, but if you are working with React you would also add ~.tsx~.
Lastly, specify ~ts-loader~ under the property =module:rules=.

- entry
- output
  - path
  - filename
- resolve
  - extensions
- module
  - rules

#+caption:Sample webpack.config.js File
#+name:sample-webpack-config-js
#+begin_src js
  module.exports = {
      entry: "./src/index.ts",
      output: {
          path: './dist',
          filename: "bundle.js"
      },
      resolve: {
          extensions: [".ts", ".tsx", ".js", ".json"]
      },
      module: {
          rules: [
              // all files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'
              { test: /\.tsx?$/,
                use: ["ts-loader"],
                exclude: /node_modules/
              }
          ]
      }
  }
#+end_src

Webpack can be run using the command-line tool ~cli.js~ using the
~webpack-cli~ tool in ~node_modules/.bin~:

: yarn webpack-cli

Alternatively, you can add a =build= script to ~package.json~ that
will run the ~webpack-cli~ tool:

: "scripts": { "build": "wepback"}

** An Example
In your editor, type the following JavaScript code in ~greeter.ts~:

#+name:greeter0.ts
#+header: :mkdirp yes
#+begin_src js :tangle examples/greeter0.ts
function greeter(person) {
    return "Hello, " + person;
}

let user = "Jane User";

document.body.textContent = greeter(user);
#+end_src

{{{heading(Compiling the Code)}}}

We used a ~.ts~ extension, but this code is just JavaScript.  You could
have copy/pasted this straight out of an existing JavaScript app.

At the command line, run the TypeScript compiler:

#+name:compile-greeter0.ts
#+header: :results output :exports both :dir examples
#+begin_src sh
tsc greeter0.ts
#+end_src

The result will be a file ~greeter0.js~ which contains the same
JavaScript that you fed in.  We’re up and running using TypeScript in
our JavaScript app!

Now we can start taking advantage of some of the new tools TypeScript
offers.  Add a =: string= type annotation to the ‘person’ function
argument as shown here:

#+name:greeter1.ts
#+header: :mkdirp yes
#+begin_src js :tangle examples/greeter1.ts
function greeter(person: string) {
    return "Hello, " + person;
}

let user = "Jane User";

document.body.textContent = greeter(user);
#+end_src

#+name:compile-greeter1.ts
#+begin_src sh :results output :exports both :dir examples
tsc greeter1.ts
#+end_src

*** Type Annotations
#+cindex:type annotation
Type annotations in TypeScript are lightweight ways to record the
intended contract of the function or variable.  In this case, we
intend the ~greeter~ function to be called with a single string
parameter.  We can try changing the call ~greeter~ to pass an array
instead:

#+name:greeter-wrong.ts
#+begin_src js :tangle examples/greeter-error.ts
function greeter(person: string) {
    return "Hello, " + person;
}

let user = [0, 1, 2];

document.body.textContent = greeter(user);
#+end_src

Re-compiling, you’ll now see an error:

#+name:compile-greeter-error.ts
#+begin_src sh :results output :exports both :dir examples
tsc greet-wrong.ts
#+end_src

: error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.

Similarly, try removing all the arguments to the greeter call.
TypeScript will let you know that you have called this function with
an unexpected number of parameters.  In both cases, TypeScript can
offer static analysis based on both the structure of your code, and
the type annotations you provide.

Notice that although there were errors, the ~greeter.js~ file is still
created.  You can use TypeScript even if there are errors in your
code.  But in this case, TypeScript is warning that your code will
likely not run as expected.

*** Interfaces
Let’s develop our sample further.  Here we use an interface that
describes objects that have a =firstName= and =lastName= field.  In
TypeScript, two types are compatible if their internal structure is
compatible.  This allows us to implement an interface just by having
the shape the interface requires, without an explicit implements
clause.

#+name:greeter-interface.ts
#+begin_src js :tangle examples/greeter-interface.ts
interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return "Hello, " + person.firstName + " " + person.lastName;
}

let user = { firstName: "Jane", lastName: "User" };

document.body.textContent = greeter(user);
#+end_src

#+name:compile-greeter-interface.ts
#+begin_src sh :results output :exports both :dir examples
tsc greeter-interface.ts
#+end_src

*** Classes
Finally, let’s extend the example one last time with classes.
TypeScript supports new features in JavaScript, like support for
class-based object-oriented programming.

Here we’re going to create a =Student= class with a constructor and a
few public fields.  Notice that classes and interfaces play well
together, letting the programmer decide on the right level of
abstraction.

Also of note, the use of =public= on arguments to the constructor is a
shorthand that allows us to automatically create properties with that
name.

#+name:greeter-class.ts
#+begin_src js :tangle examples/greeter-class.ts
class Student {
    fullName: string;
    constructor(public firstName: string, public middleInitial: string, public lastName: string) {
        this.fullName = firstName + " " + middleInitial + " " + lastName;
    }
}

interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return "Hello, " + person.firstName + " " + person.lastName;
}

let user = new Student("Jane", "M.", "User");

document.body.textContent = greeter(user);
#+end_src

#+name:compile-greeter-class.ts
#+begin_src sh :results output :exports both :dir examples
tsc greeter-class.ts
#+end_src

Run ~tsc greeter-class.ts~ and you’ll see the generated JavaScript is
the same as the earlier code.  Classes in TypeScript are just a
shorthand for the same prototype-based OO that is frequently used in
JavaScript.

*** Running your TypeScript Web App
Now type the following in ~greeter.html~:

#+name:greeter.html
#+begin_src html :tangle examples/greeter.html
<!DOCTYPE html>
<html>
    <head><title>TypeScript Greeter</title></head>
    <body>
        <script src="greeter-class.js"></script>
    </body>
</html>
#+end_src

Open ~greeter.html~ in the browser to run your first simple TypeScript
web application!

#+name:open-greeter-class.html
#+begin_src sh :results output :exports both :dir examples
open greeter.html
#+end_src
* Type System
#+cindex:types
#+cindex:type system
#+cindex:static type system
#+cindex:type annotations
#+cindex:constraints
#+cindex:inference
#+cindex:type inference
#+cindex:@code{Any} type
TypeScript adds a static type system on top of JavaScript.  Type
annotations place a specific set of constraints on top of variables
being created.  These constraints allow the compiler and development
tools to better assist in the proper use of the object.  This includes
a list of functions, variables, and. properties available on the
object.  If a variable is created but no type is provided for it,
TypeScript will attempt to infer the type from the context in which it
is used.  When an object's type is not given and cannot be inferred
from its initialization, then it will be treated as an =Any= type.  It
can represent any JavaScript value and the minimum amount of type
checking is performed on objects of type =Any=.

{{{heading(Categories)}}}

#+cindex:types, list of
#+cindex:primitive types
#+cindex:object types
#+cindex:type parameters
#+cindex:Boolean type
#+cindex:Number type
#+cindex:String type
#+cindex:Undefined
#+cindex:Void
#+cindex:Null
Every other type (than =Any=) that exists in TypeScript falls into one
of three categories:

- Primitives
  - Boolean
  - Number
  - String
  - Null
  - Undefined
  - Void
- Objects
- Type Parameters (Generics)


{{{heading(Type Parameters)}}}

Type parameters are used when referencing generic types or calling
generic functions.  They are used to keep code generic enough to be
used on a multitude of objects while limiting those objects to a
specific set of constraints.  An example of generics is arrays.
Arrays exist just as in JavaScript; they have an extra set of
constraints placed on them.  The =array= object itself has certain
type constraints and methods that are created as being an object of
the =Array= type.  The second piece of information that comes from the
array declaration is the type of the objects contained in the array.
There are two ways to explicitly type an array; otherwise the
contextual typing system will attempt to infer the type information.

: var array1: string[] = [];
: var array2: Array<string> = [];

Both of these ways produce the same type information and the same
JavaScript output.  The first is a shorthand using the type literal
=[]=.

#+cindex:types
** Primitive Types
#+cindex:primitive types
#+cindex:@code{Void} type
All primitive types correspond directly to JavaScript's primitive
types except =Void=.  The =Void= type is meant to represent the
absence of a value.  A function that returns no value has a return
type of ~void~.

*** Boolean ~boolean~
#+cindex:boolean type
- =true=
- =false=


: let isDone: boolean = false;

*** Number ~number~
#+cindex:number type
All numbers are floating-point values; numbers include binary, octal,
hexadecimal and decimal literals.

: let decimal: number = 6;
: let hex: number = 0xf00d;
: let binary: number = 0b1010;
: let octal: number = 0o744;

*** String ~string~
#+cindex:string type
The type =string= refers to the textual datatype.  TypeScript uses
either double quotes or single quotes to surround string data.

: let color: string = "blue";
: color = 'red';

{{{heading(Template Strings)}}}

Template strings are strings surrounded by the backtick or backquote
character (=`=); template strings can span multiple lines and allow
embedded expressions using the syntax =${ expr }=.

: let sentence: string = `Hello, my name is ${ fullName }.`

*** Null ~null~
#+cindex:null type
The type =null= is the only value of this type.  It is a subtype of
all other types, though, which means you can assign =null= to any
other type, unless {{{option(--strictNullChecks)}}} is used, in which
case =null= can only be assigned to an =any= type.

*** Undefined ~undefined~
#+cindex:undefined type
The type =undefined= is the only value of this type.  It is a subtype
of all other types as is =null=.  When
{{{option(--stringNullChecks)}}} is used, =undefined= can be assigned
to a type of =any= and =void=.

*** Void ~void~
#+cindex:void type
The =void= type denotes the absence of having any type at all.  You
may commonly see this as the return type of functions that do not
return a value:

#+begin_src js
function warnUser(): void {
    console.log("This is my warning message");
}
#+end_src

Declaring variables of type =void= is not useful because you can only
assign =undefined= or =null= to them.

** Object Types
#+cindex:object types
#+cindex:members, object
#+cindex:object members
#+cindex:properties
#+cindex:call signatures
#+cindex:constructor signatures
#+cindex:index signatures
#+cindex:signatures
Object types are the most common types in TypeScript.  They are made
up of references to classes, interfaces, and anonymous object types.
Object types are made up of a complex set of members.  These members
fall into one of four categories:
- properties,
- call signatures,
- constructor signatures, or
- index signatures.

*** Array
#+cindex:array type
Array types can be written in one of two ways.

In the first, you use the type of the elements followed by =[]= to
denote an array of that element type:

: let list: number[] = [1, 2, 3];

The second way uses a generic array type, =Array<elemType>=:

: let list: Array<number> = [1, 2, 3];

*** Tuple
#+cindex:tuple type
Tuple types allow you to express an array with a fixed number of
elements whose types are known, but need not be the same.

To represent a value as a pair of a string and a number:

#+begin_src js
// Declare a tuple type
let x: [string, number];
// Initialize it
x = ["hello", 10]; // OK
// Initialize it incorrectly
x = [10, "hello"]; // Error
#+end_src

When accessing an element with a known index, the correct type is
retrieved:

: console.log(x[0].substring(1)); // OK

*** Enum
#+cindex:enum type
An enum is a way of giving more friendly names to sets of numeric
values.

#+begin_src js
enum Color {Red, Green, Blue}
let c: Color = Color.Green;
#+end_src

{{{heading(Enum Numbering)}}}

By default, enums begin numbering their members starting at 0.  You
can change this by manually setting the value of one of its members.
For example, we can start the previous example at 1 instead of 0:

#+begin_src js
enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;
#+end_src

{{{subheading(Manual Enum Numbering)}}}

Or, even manually set all the values in the enum:

#+begin_src js
enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
#+end_src

{{{subheading(Enum Values to Name)}}}

A handy feature of enums is that you can also go from a numeric value
to the name of that value in the enum.  For example, if we had the
value 2 but weren’t sure what that mapped to in the Color enum above,
we could look up the corresponding name:

#+begin_src js
enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

console.log(colorName); // Displays 'Green' as its value is 2 above
#+end_src

** Any
#+cindex:any type
We may need to describe the type of variables that we do not know when
we are writing an application.  These values may come from dynamic
content, e.g. from the user or a 3rd party library.  In these cases,
we want to opt-out of type checking and let the values pass through
compile-time checks.  To do so, we label these with the =any= type:

#+begin_src js
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean
#+end_src

{{{heading(Objects and Type =any=)}}}

Variables of type =Object= only allow you to assign =any= value to
them.  You can’t call arbitrary methods on them, even ones that
actually exist:

#+begin_src js
let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.
#+end_src

The =any= type is also handy if you know some part of the type, but
perhaps not all of it.  For example, you may have an array but the
array has a mix of different types:

#+begin_src js
let list: any[] = [1, true, "free"];

list[1] = 100;
#+end_src

** Union Type
#+cindex:union type
In cases where you want to pass in either a =string= or =null= or
=undefined=, you can use the =union= type =string | null | undefined=.

** Never
#+cindex:never type
The =never= type represents the type of values that never occur.  For
instance, =never= is the return type for a function expression or an
arrow function expression that always throws an exception or one that
never returns.  Variables also acquire the type =never= when narrowed by
any type guards that can never be true.

The =never= type is a subtype of, and assignable to, every type;
however, no type is a subtype of, or assignable to, =never= (including
=any=).

Some examples of functions returning never:

#+begin_src js
// Function returning never must have unreachable end point
function error(message: string): never {
    throw new Error(message);
}

// Inferred return type is never
function fail() {
    return error("Something failed");
}

// Function returning never must have unreachable end point
function infiniteLoop(): never {
    while (true) {
    }
}
#+end_src

** Object
#+cindex:object type
The =object= is a type that represents the non-primitive type,
i.e. anything that is not =number=, =string=, =boolean=, =symbol=,
=null=, or =undefined=.

With object type, APIs like ~Object.create~ can be better
represented.  For example:

#+begin_src js
declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
#+end_src

** Type Assertions
#+cindex:type assertions
In cases in which TypeScript determines that an assignment is invalid,
but you know that you are dealing with a special case, you can
override the type using a /type assertion/.  When you use a type
assertion, you are taking responsibility from the compiler and must
ensure that the assignment is valid. Your program may not work
correctly if you make a mistake.

Sometimes you’ll end up in a situation where you’ll know more about a
value than TypeScript does.  Usually this will happen when you know
the type of some entity could be more specific than its current type.

/Type assertions/ are a way to tell the compiler “trust me, I know
what I’m doing.”  A type assertion is like a type cast in other
languages, but performs no special checking or restructuring of data.
It has no runtime impact, and is used purely by the compiler.
TypeScript assumes that you, the programmer, have performed any
special checks that you need.

{{{heading(Type Assertion Forms)}}}

Type assertions have two forms (that is, the forms are equivalent
symantically).

{{{subheading(Angle Bracket Syntax)}}}

1. the “angle-bracket” syntax:

#+begin_src js
let someValue: any = "this is a string";

let strLength: number = (<string>someValue).length;
#+end_src

{{{subheading(As Syntax)}}}

2. the other is the as-syntax:

#+begin_src js
let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
#+end_src

When using TypeScript with JSX, only =as=-style assertions are
allowed.
** Type Aliases
#+cindex:type alias
#+cindex:alias, type
Declare a type alias that points to a type:

#+begin_src js
  type Age = number

  type Person = {
      name: string
      age: Age
  }
#+end_src

=Age= is a number, but it helps annotate what =age= is inside a
=Person= object.

#+begin_src js
  let age : Age = 55; //     let age = 55 also works

  let driver: Person = {
      name: 'John Doe'
      age: age
  }
#+end_src

#+cindex:block-scoped, type alias
Type aliases are block-scoped.  Every block and every function has its
own scope, and inner type alias declarations shadow outer ones.
** Union and Intersection Types
#+cindex:union types
#+cindex:types, union
#+cindex:intersection
If you have two things =A= and =B=, the /union/ of those things is
their sum (everything in =A= or =B= or both), and the /intersection/
is everything in both =A= and =B=.

*** Union Types
#+cindex:union type
#+cindex:widen
A /union type/ *widens* the allowable values by specifying that the
value can be of more than a single type.

TypeScript gives us special type operators to describe unions and
intersections of types:

- =|= :: union

- =&= :: intersection


For example, it is possible to create a type that is either a =Boolean
or a =number=.  Union types use the pipe-delimeter (=|=) to separate
each of the possible types, which you can read as an =OR=.  Attempting
to supply a value that doesn’t match one of the types in the union
results in an error.

#+begin_example
let union: boolean | number;
union = 5;
union = true;

union = 'string'; // Error: Type "string" is not assignable to type 'number | boolean'
#+end_example

{{{heading(Type Alias for a Union Type)}}}

When creating a union type, consider using a type alias to reduce the
repetition of the definition in your program and to give the concept a
name. A union can be created using any types available in your
program, not just primitive types.

The type alias for a union type is:

: type StringOrError = string | Error;

*** Intersection Types
#+cindex:intersection types
#+cindex:type, intersection
#+cindex:supertype
An /intersection type/ combines several different types into a single
supertype that includes the members from all participating types.
Where a union type is “either type A or B,” an intersection type is
“both type A and B.”

#+caption:Intersection Type
#+name:intersection-type
#+begin_src js
  interface Skier {
      slide(): void;
  }

  interface Shooter {
      shoot(): void;
  }

  type Biathelete = Skier & Shooter;
#+end_src

#+cindex:mixins
Intersection types are useful for working with mixins

*** Further Examples

#+begin_src js
type Cat = {name: string, purrs: boolean}
type Dog = {name: string, barks: boolean, wags: boolean}

type CatOrDogOrBoth = Cat | Dog

type CatAndDog = Cat & Dog
#+end_src

If something is a =CatOrDogOrBoth=, what do you know about it?  You
know that it has a =name= property that’s a string, and not much else.
On the flip side, what can you assign to a =CatOrDogOrBoth=?  Well, a
=Cat=, a =Dog=, or both:

#+begin_src js
  // Cat
  let a: CatOrDogOrBoth = {
    name: 'Bonkers',
    purrs: true
  }

  // Dog
  a = {
    name: 'Domino',
    barks: true,
    wags: true
  }

  // Both
  a = {
    name: 'Donkers',
    barks: true,
    purrs: true,
    wags: true
  }
#+end_src

This is worth reiterating: a value with a /union/ type (=|=) isn’t
necessarily one specific member of your union; in fact, it can be both
members at once!

On the other hand, what do you know about CatAndDog?  Not only does
your canine-feline hybrid super-pet have a name, but it can purr,
bark, and wag:

#+begin_src js
  let b: CatAndDog = {
    name: 'Domino',
    barks: true,
    purrs: true,
    wags: true
  }
#+end_src

Unions come up naturally a lot more often than intersections do.  Take
this function, for example:

#+begin_src js
  function trueOrNull(isTrue: boolean) {
    if (isTrue) {
      return 'true'
    }
    return null
  }
#+end_src

What is the type of the value this function returns?  Well, it might
be a string, or it might be null.  We can express its return type as:

#+begin_src js
type Returns = string | null
#+end_src

What about the return type of this function?

#+begin_src js
function(a: string, b: number) {
  return a || b
#+end_src

If a is truthy then the return type is string, and otherwise it’s
number: in other words,

#+begin_src js
type Returns = string | number
#+end_src

** Literal Types
#+cindex:literal types
#+cindex:types, literal
#+cindex:narrow
Literal types can be used to narrow the range of allowable values to a
subset of the type, such as reducing a string, to a set of specific
values.

#+caption:Literal type example
#+name:literal-type
#+begin_src js
  type Kingdom = 'Bacteria' | 'Protozoa' | 'Chromista' | 'Plantae' | 'Fungi' | 'Animalia';

  let kingdom: Kingdom;

  // OK
  kingdom = 'Bacteria';

  // Error: Type 'Protista' is not assignable to type 'Kingdom'
  kingdom = 'Protista';
#+end_src

#+cindex:union type
Literal types are really just union types made up of specific values,
so you can also create a number literal type, or a union/literal
hybrid type using the same syntax.

#+begin_src js
  // Number literal type
  type Fibonacci = 1 | 2 | 3 | 5 | 8 | 13;

  let num: Fibonacci;

  // OK
  num = 8;

  // Error: Type '9' is not assignable to type 'Fibonacci'
  num = 9;

  // Hybrid union/literal type
  type Randoms = 'Text' | 10 | false;

  let random: Randoms;

  // OK
  random = 'Text';
  random = 10;
  random = false;

  // Error: Not assignable.
  random = 'Other String';
  random = 12;
  random = true;
#+end_src

#+cindex:enumeration, literal type
#+cindex:literal type, enumeration
The behavior of literal types is similar to the behavior of
enumerations, so if you are using only numbers in your literal type,
consider whether an enumeration would be more expressive in your
program.
* Types---An Introduction
#+cindex:static typing
TypeScript is optionally statically typed.  It is possible to opt out
of this by declaring dynamic variables.  You can also create types to
replace primitive types.  Static typing allows development tools to
provide intelligent autocompletion.

** Type Annotations
#+cindex:type annotation
The TypeScript language service is expert at inferring types
automatically.  However, there are times when it can’t fathom your
intentions.  There will also be times where you will wish to make a
type explicit for safety or to narrow the type.  In these cases, you
can use a /type annotation/ to specify the type.

The type used to specify an annotation can be a primitive type, an
array type, a function signature, a type alias, or any complex
structure you want to represent including the names of classes and
interfaces you create.  You can also be permissive by allowing one of
multiple types (union types), or more restrictive by limiting the
range of allowable values (literal types).  If you want to opt out of
static type checking, you can use the special any type, which marks a
variable’s type as dynamic.  No checks are made on dynamic types.

{{{heading(Example of Type Annotations)}}}

{{{subheading(Variable Type Annotations)}}}

For a variable, the type annotation comes after the identifier and is
preceded by a colon.

: const variable : type ;
: const variable : type = value ;

{{{subheading(Array Type Annotation)}}}

: const names : string[] ;

{{{subheading(Function Type Annotation)}}}

: let sayHello : (name: string) => string ;

{{{subheading(Object Type Annotation)}}}

: let person : { name : string; heightinCentimeters : number; }

{{{heading(Interfaces and Type Aliases)}}}

#+cindex:interface
#+cindex:@code{extends} clause
#+cindex:@code{implements} clause
#+cindex:generic interface
#+cindex:type argument
#+cindex:type alias
If a type annotation becomes too complex, you can create an interface,
or a type alias to represent the type to simplify annotations.  An
interface can be used in an ~extends~ or ~implements~ clause, which
means you can explicitly use them when defining other interfaces and
classes.  An interface can also accept type arguments, making the
interface generic.  A type alias can do neither of these.

#+BEGIN_SRC js -n
  // Interface
  interface PersonInterface {
      name : string;
      heightInCentimeters;
  }

  // Type Alias
  type PersonType = {
      name : string;
      heightInCentimeters;
  };
#+END_SRC

** Primitive Types
#+cindex:primitive types
The primitive types in TypeScript are incredibly basic, but through
the tools of the type system you can combine them, widen them, and
narrow them to represent the concepts in your program.  These types
directly represent the underlying JavaScript types and follow the
standards set for those types:

- ~string~ :: a sequence of UTF-16 code units

- ~boolean~ :: =true= or =false=

- ~number~ :: a double-precision 64-bit floating point value; there
              are no special types to represent integers or other
              specific variations on the numeric type as it wouldn’t
              be practical to perform static analysis to ensure all
              possible values assigned are valid.

- ~symbol~ :: a unique, immutable symbol, substitutable for a string
              as an object key

- ~undefined~ :: the value of a variable that has not been assigned a
                 value.

- ~null~ :: can be used to represent an intentional absence of an
            object value.

- ~void~ :: used to represent cases where there is no value, for
            example, to show that a function doesn’t return anything.

- ~never~ :: represents an unreachable section of code, for example a
             function that throws an exception has the return type of
             never.

** Object and Dynamic Types
#+cindex:object types
#+cindex:dynamic types
Everything that isn’t a primitive type in TypeScript is a subclass of
the =object= type.

#+cindex:@code{any} type
#+cindex:implicit @code{any} type
The final types is the dynamic =any= type, which can be used to
represent literally any type.  When using dynamic types, there is no
compiler type checking for the type.

The implicit =any= type is also used by the compiler in situations
where it cannot infer the type automatically.  You can disallow these
implicit =any= types using a complier flag.  You can also use it in
cases where you don’t want the type to be checked by the compiler,
which gives you access to all of the dynamic features of the
JavaScript language.

** Enumerations
Enumerations are one of the simplest /narrowing/ types.  Enumerations
represent a collection of named elements that you can use to avoid
littering your program with hard-coded values.  By default,
enumerations are zero based although you can change this by specifying
the first value, in which case numbers will increment from value you
set. You can opt to specify values for all identifiers if you wish to.

#+BEGIN_SRC js -n
  enum VehicleType {
      PedalCycle,
      MotorCycle,
      Car,
      Van,
      Bus,
  Lorry }

  const type = VehicleType.Lorry
  const typeName = VehicleType[type]; // 'Lorry'
#+END_SRC

*** Enumerations and Bit Flags
You can use an enumeration to define bit flags.  Bit flags allow a
series of items to be selected or deselected by switching individual
bits in a sequence on and off.  To ensure that each value in an
enumeration relates to a single bit, the numbering must follow the
binary sequence whereby each value is a power of two:

: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1,024, 2,048, 4,096, and so on

[[enumerations-and-big-flags][Bit Flags]] for an example of using an enumeration for bit flags. By
default, when you create a variable to store the state, all items are
switched off.  To switch on an option, it can simply be assigned to
the variable.  To switch on multiple items, items can be combined with
the bitwise OR operator (|).  Items remain switched on if you happen
to include them multiple times using the bitwise OR operator.

#+caption:Enumeration and Big Flags
#+name:enumerations-and-big-flags
#+begin_src js -n
  enum DiscFlags {
      None = 0,
      Drive = 1,
      Influence = 2,
      Steadiness = 4,
      Conscientiousness = 8
  }
  // Using flags
  var personality = DiscFlags.Drive | DiscFlags.Conscientiousness;
  // Testing flags
  // true
  var hasD = (personality & DiscFlags.Drive) == DiscFlags.Drive;
  // false
  var hasI = (personality & DiscFlags.Influence) == DiscFlags.Influence;
  // false
  var hasS = (personality & DiscFlags.Steadiness) == DiscFlags.Steadiness;
  // true
  var hasC = (personality & DiscFlags.Conscientiousness) == DiscFlags.Conscientiousness;
#+end_src

*** Enumeration Values
The value assigned to each item in an enum can be constant, or
computed.

Constant values are any expression that can be interpreted by the type
system, such as literal values, calculations, and binary operators.

Computed values are expressions that could not be efficiently
interpreted by the compiler, such as assigning a string length, or
calling out to a method.

The terminology here is dangerously overloaded; the term “constant”
when considering “constant vs computed” should not be confused with
the ~const~ keyword, which can be used with variables and with a
special kind of enumeration, called a /constant enumeration/.

*** Constant Enumeration
A constant enumeration can be created using the ~const~ keyword.
Unlike a normal enumeration, a constant enumeration is erased during
compilation and all code referring to it is replaced with hard-coded
values.

#+begin_src js -n
  const enum VehicleType {
      PedalCycle,
      MotorCycle,
      Car,
      Van,
      Bus,
      Lorry
  }

  const type = VehicleType.Lorry; // var type = 5 /* Lorry */;
#+end_src

** Union Types
#+cindex:union type
A union type widens the allowable values by specifying that the value
can be of more than a single type.  Libraries such as jQuery commonly
expose functions that allow you to pass either a jQuery object, or a
string selector, for example; and union types allow you to limit the
possible values to just these two types (rather than resorting to a
completely dynamic type).  It is possible to create a type that is
either a Boolean or a number.

Union types use the pipe-delimeter to separate each of the possible
types, which you can read as an “OR.”  Attempting to supply a value
that doesn’t match one of the types in the union results in an error.

#+begin_src js -n
  // Type annotation for a union type
  let union: boolean | number; // OK: number
  union = 5;
  // OK: boolean
  union = true;
  // Error: Type "string" is not assignable to type 'number | boolean'
  union = 'string';
  // Type alias for a union type
  type StringOrError = string | Error;
  // Type alias for union of many types
  type SeriesOfTypes = string | number | boolean | Error;
#+end_src

#+cindex:type alias
When creating a union type, consider using a /type alias/ to reduce
the repetition of the definition in your program and to give the
concept a name. A union can be created using any types available in
your program, not just primitive types.

** Literal Types
Literal types can be used to narrow the range of allowable values to a
subset of the type, such as reducing a string, to a set of specific
values.  Literal types are really just union types made up of specific
values, so you can also create a number literal type, or a
union/literal hybrid type using the same syntax.

#+begin_src js -n
  type Kingdom = 'Bacteria' | 'Protozoa' | 'Chromista' | 'Plantae' | 'Fungi' | 'Animalia';
  let kingdom: Kingdom;
  // OK
  kingdom = 'Bacteria';
  // Error: Type 'Protista' is not assignable to type 'Kingdom'
  kingdom = 'Protista';

  // Number literal type
  type Fibonacci = 1 | 2 | 3 | 5 | 8 | 13; let num: Fibonacci;
  // OK num = 8;
  // Error: Type '9' is not assignable to type 'Fibonacci'
  num = 9;
  // Hybrid union/literal type
  type Randoms = 'Text' | 10 | false;
  let random: Randoms;
  // OK
  random = 'Text';
  random = 10;
  random = false;
  // Error: Not assignable.
  random = 'Other String';
  random = 12;
  random = true;
#+end_src

** Intersection Types
#+cindex:intersection type
#+cindex:mixin
An intersection type combines several different types into a single
supertype that includes the members from all participating types.
Where a union type is “either type A or B,” an intersection type is
“both type A and B.”  Intersection types are useful for working with
mixins.

Below are two interfaces for =Skier= and =Shooter=, which are combined
into the =Biathelete= intersection type.  Intersection types use the
ampersand character, which you can read as “AND.”

#+begin_src js -n
interface Skier {
    slide(): void;
}
interface Shooter {
    shoot(): void;
}
type Biathelete = Skier & Shooter;
#+end_src

** Array Types
#+cindex:array types
TypeScript arrays have precise typing for their contents.  To specify
an array type, you simply add square brackets after the type name.
This works for all types whether they are primitive or custom types.
When you add an item to the array, its type will be checked to ensure
it is compatible.  When you access elements in the array, you will get
quality autocompletion because the type of each item is known.

#+begin_src js -n
  interface Monument {
      name: string;
      heightInMeters: number;
  }

  // The array is typed using the Monument interface
  const monuments: Monument[] = []; // or Array<Monument>

  // Each item added to the array is checked for type compatibility
  monuments.push({
      name: 'Statue of Liberty',
      heightInMeters: 46
  });
#+end_src

** Tuple Types
A tuple type uses an array, and specifies the type of elements based
on their position.

#+begin_src js -n
  let poem: [number , boolean , string];
  // OK
  poem = [1, true, 'love'];

  // Error: 'string' is not assignable to 'number'
  poem = ['my', true, 'love'];
#+end_src

** Dictionary Types
You can represent dictionaries in TypeScript using an index type.  The
index type specifies the key and its type in square brackets, and the
type of the value afterwards as a type annotation.

#+begin_src js -n
  interface Cephalopod {
      hasInk: boolean;
      arms: number;
      tentacles: number;
  }

  interface CephalopodDictionary {
      [index: string]: Cephalopod;
  }

  let dictionary: CephalopodDictionary = {};

  dictionary['octopus vulgaris'] = { hasInk: true, arms: 8, tentacles: 0 };
  dictionary['loligo vulgaris'] = { hasInk: true, arms: 8, tentacles: 2 };

  // Error. Not assignable to type 'Cephalopod'
  dictionary[0] = { hasInk: true };
#+end_src

** Mapped Types
To reduce the amount of effort required to create similar types that
differ only in optionality, or readability, mapped types allow you to
create variations of an existing type in a single expression.  Mapped
types use the keyof keyword, which is an index type query that gathers
a list of permitted property names for a type in your program.

#+begin_src js -n
  interface Options {
      material: string;
      backlight: boolean;
  }

  // Mapped types
  type ReadOnly<T> = { readonly [k in keyof T]: T[k]; }
  type Optional<T> = {[k in keyof T]?: T[k]; }
  type Nullable<T> = {[k in keyof T]: T[k] | null; }

  // Creating new types from mapped types
  type ReadonlyOptions = Readonly<Options>;
  type OptionalOptions = Optional<Options>;
  type NullableOptions = Nullable<Options>;
#+end_src

** Type Assertions
In cases in which TypeScript determines that an assignment is invalid,
but you know that you are dealing with a special case, you can
override the type using a type assertion.  When you use a type
assertion, you are taking responsibility from the compiler and must
ensure that the assignment is valid.  The type assertion precedes a
statement.

: (<type_assertion>property).member

Although a type assertion overrides the type as far as the compiler is
concerned, there are still checks performed when you assert a type. It
is possible to force a type assertion by adding an additional <any>
type assertion between the actual type you want to use and the
identifier of the variable.

: <type_assertion><any>member

** Type Guards
When dealing with a wide type definition, you may find you need to
narrow it in order to use a member that would otherwise be
unavailable.  A type guard is a statement that results in the type
becoming narrower.  The standard type guards include ~typeof~ and
~instanceof~; but if that doesn’t cover your situation, you can write
your own custom type guard.

: typeof stringNumber === 'string'
: treadmill is SpeedControllable

** Discriminated Unions
A discriminated union, or tagged union, allows you to combine union
types, type aliases, and type guards to get full autocompletion and
checking for types with a common string literal property.  The
components that make up a discriminated union are the following:

1. Several types that share a common string literal property, called a
   /discriminant/.

2. A type alias for a union of these types, called a union.

3. A type guard that checks the discriminant.


The =cube= and =cuboid= types both share the discriminant “kind.”  The
types are added to the =prism= union, which results in full
autocompletion in the ~switch~ statement in the ~volume~ function.
The ~switch~ statement acts as a type guard, meaning the type of
=prism= in each case is the correct narrowed type.  The default case
is used like a safety net to ensure there are no types that are part
of the discriminated union that have been left out of the ~switch~
statement.

#+begin_src js -n
  nterface Cube {
      kind: 'cube'; // Discriminant
      size: number;
  }

  interface Cuboid {
      kind: 'cuboid'; // Discriminant
      width: number;
      depth: number;
      height: number;
  }

  // Union
  type Prism = Cube | Cuboid;

  function volume(prism: Prism): number {
      // Type Guard
      switch (prism.kind) {
          case 'cube':
              return prism.size * prism.size * prism.size;
          case 'cuboid':
              return prism.width * prism.depth * prism.height;
          default:
              assertNever(prism);
          break;
      }
  }

  function assertNever(arg: never): never {
      throw new Error("Possible new tagged type: " + arg);
  }
#+end_src

If you are following an object-oriented approach, you might not get
much mileage from this feature, but it is a common use case for
functional programming.
* Operators
All the standard JavaScript operators are available within your
TypeScript program.  This section describes operators that have
special significance within TypeScript because of type restrictions or
because they affect types.

** Increment and Decrement
The increment (~++~) and decrement (~--~) operators can only be
applied to variables of type =any=, =number=, or =enum=.

** Binary Operators
The operators in the following list are designed to work with two
numbers. In TypeScript, it is valid to use the operators with
variables of type number or any.

: - * / % << >> >>> & ^ |

The plus (~+~) operator is absent from this list because it is a
special case: a mathematical addition operator as well as a
concatenation operator.  Whether the addition or concatenation is
chosen depends on the type of the variables on either side of the
operator.

The rules for determining the type resulting from a plus operation are
the following:

- If the type of either of the arguments is a string, the result is
  always a string.

- If the type of both arguments is either number or enum, the result
  is a number.

- If the type of either of the arguments is any, and the other
  argument is not a string, the result is any.

- In any other case, the operator is not allowed.


When the plus operator is used with only a single argument, it acts as
a shorthand conversion to a number.  The unary minus operator also
converts the type to number and changes its sign.

** Bitwise Operators
Bitwise operators in TypeScript accept values of all types.  The
operator treats each value in the expression as a sequence of 32 bits
and returns a number.  Bitwise operators are useful for working with
Flags.

: & | ^ << >> >>> ~

** Logical Operators
Logical operators are usually used to test Boolean variables or to
convert an expression into a Boolean value. This section explains how
logical operators are used in TypeScript for this purpose, and how
logical AND and logical OR operators can be used outside of the
context of Boolean types.

*** NOT ! Operator
The NOT operator can be used in TypeScript in ways that affect types.
In the same way the unary plus operator can be used as a shorthand
method for converting a variable of any type to a number, the NOT
operator can convert any variable to a Boolean type.  This can be done
without inverting the truth of the variable by using a sequence of two
unary NOT operators (!!).

It is worth familiarizing yourself with the concepts of “truthy” and
“falsey” that apply to this operation. The term falsey applies to
certain values that are equivalent to false when used in a logical
operation. Everything else is “truthy” and is equivalent to true. The
following values are “falsey” and are evaluated as false:

- undefined

- null

- false : boolean

- '' : string (empty string)

- 0 : number

- NaN : (Not a Number)


All other values are evaluated as true.

#+begin_src js -n
  var myProperty;
  if (myProperty) {
      // Reaching this location means that...
      // myProperty is not null
      // myProperty is not undefined
      // myProperty is not boolean false
      // myProperty is not an empty string
      // myProperty is not the number 0
      // myProperty is not NaN
  }
#+end_src

*** AND && Operator
The AND operator can also be used outside of a logical context because
the right-hand side of the expression is only evaluated if the
left-hand side is truthy.  Where the result of the expression is
assigned to a variable, the variable will always have the type of the
right-hand expression.

*** OR || Operator
The less common use of the OR operator is to coalesce two values,
substituting a value on the left with one on the right in cases where
the left-hand value is falsey.

*** Short Circuit Evaluation
Both the logical AND operator and the logical OR operator benefit from
short-circuit evaluation.  This means that as soon as the statement
can be logically answered, evaluation stops.  While this saves the
processing of the second statement, the real benefit is that it means
you can ensure a value is defined before you use it.

*** Conditional Operator
: ? :

** Type Operators
- typeof

- instanceof

- in

- delete

** Destructuring
Destructuring allows you to unpack an array or object into named
variables.  You can also use rest parameters when destructuring. Rest
parameters are preceded by the three-dot (...) prefix and crop up in
other areas too, such as functions.  The rest parameter must appear
last in the list, and it will receive all the values left after the
named arguments have been unpacked.

#+begin_src js -n
  const triangles = [1, 3, 6, 10, 15, 21];

  // Destructuring
  const [first, second] = triangles;

  // Destructuring with a rest argument
  const [first, second, ...remaining] = triangles;

  // Skipping third item
  const [first, second, , fourth] = triangles;

  // Swapping
  [a, b] = [b, a];
#+end_src

You can also use destructuring to unpack objects.  The syntax for
object destructuring is slightly different.  The left-hand side of the
expression looks like an object literal, but where the values are
actually the new variables that will be assigned the values that
appear on their left.  You can think of destructuring as array
literals that extract data, and object literals that extract data.

You can also auto-unpack objects if you use variable names that match
the property names.

#+begin_src js -n
  const highSchool = { school: 'Central High', team: 'Centaurs' };

  // Object destructuring
  const { school: s, team: t } = highSchool;

  // 'Central High'
  console.log(s);

  // 'Centaurs'
  console.log(t);

  // Auto-unpacking
  const { school, team } = highSchool;

  const pets = { cat: 'Pickle', dog: 'Berkeley', hamster: 'Hammy'}

  // Object destructuring
  const { dog, ...others } = pets;

  const triangles = [1, 3, 6];

  // Default values
  // Destructuring past available values
  const [first, second, third = -1, fourth = -1] = triangles;
#+end_src

Tuples and destructuring are a powerful combination. If you have a
method that returns a tuple, you can immediately destructure it into
named variables. This keeps the lifespan of the tuple type as short as
possible and expresses the return value better by making each variable
explicit.

#+begin_src js -n
  // Returning a tuple
  function getThreeLandmarks(): [string, string, string] {
      return ['Golden Gate Bridge', 'Palace of Westminster', 'Colosseum '];
  }

  // Destructuring the tuple into named variables
  const [sanFrancisco, london, rome] = getThreeLandmarks();
#+end_src

** Spread Operator
The spread operator does the opposite of destructuring and can be used
to pack arrays and objects using a shallow copy.  The spread operator
works with properties, but sadly not methods.

#+begin_src js -n
  const squares = [1, 4, 9, 16, 25];
  const powers = [2, 4, 8, 16, 32];

  // Array spreading
  const squaresAndPowers = [...squares, ...powers];

  // [1, 4, 9, 16, 25, 2, 4, 8, 16, 32]
  console.log(squaresAndPowers);

  const emergencyService = {
      police: 'Chase',
      fire: 'Marshall',
  };

  const utilityService = {
      recycling: 'Rocky',
      construction: 'Rubble'
  };

  // Object spreading
  const patrol = { ...emergencyService, ...utilityService };

  // { police: 'Chase', fire: 'Marshall', recycling: 'Rocky', construction: 'Rubble' }
  console.log(patrol);
#+end_src

* Functions
#+cindex:functions
In TypeScript, while there are classes, namespaces, and modules,
functions still play the key role in describing how to do things.
TypeScript also adds some new capabilities to the standard JavaScript
functions to make them easier to work with.

#+cindex:function, named
#+cindex:function, anonymous
#+cindex:anonymous function
To begin, just as in JavaScript, TypeScript functions can be created
both as a named function or as an anonymous function.  This allows you
to choose the most appropriate approach for your application, whether
you’re building a list of functions in an API or a one-off function to
hand off to another function.

To quickly recap what these two approaches look like in JavaScript:

#+caption:A Named Function and an Anonymous Function
#+name:named-function-anonymous-function
#+begin_src js
// Named function
function add(x, y) {
    return x + y;
}

// Anonymous function
let myAdd = function(x, y) { return x + y; };
#+end_src

#+cindex:capture variables
Just as in JavaScript, functions can refer to variables outside of the
function body.  When they do so, they’re said to capture these
variables.  Having a firm understanding how this mechanic works is an
important piece of working with JavaScript and TypeScript.

#+begin_src js
let z = 100;

function addToZ(x, y) {
    return x + y + z;
}
#+end_src

** What TypeScript Adds to Functions

- type annotations
- optional parameters
- default parameters
- rest parameters
- overloads


#+cindex:function type annotations
#+cindex:@code{rest} parameters
Typescript has added type annotations to the parameter list as well as
the return type.  Due to the new constraints being placed on the
parameter list, the concept of function overloads was also included in
the language specification.  TypeScript also takes advantage of
JavaScript's =arguments= object and provides syntax for =rest=
parameters.  Here is an example of a function declaration in
TypeScript:

#+begin_src js -n
function add(x: number, y: number): number {
   return x + y;
}
#+end_src

#+cindex:optional parameters
TypeScript provides a way to provide optional parameters to functions:

#+begin_src js -n
  function add(x: number, y: number, z?: number) {
      if (z != undefined) {
          return x + y + z;
      }
      return x + y;
  }
#+end_src

Optional parameters tell the compiler not to generate an error if the
parameter is not provided when the function is called.  In JavaScript,
this compile-time checking is not performed, meaning an exception
could occur at runtime because each missing parameter will have a
value of =undefined=.

#+cindex:overloaded functions
The above function can be overloaded to add strings as well as
numbers:

#+begin_src js -n
  function add(x: string, y: string): string;
  function add(x: number, y: number): number;
  function add(x: any, y: any): {
      return x + y;
  }
#+end_src

Attempting to call the ~add~ method with anything other than a number
or string will fail at compile time, but the overloads have no effect
on the generated JavaScript.  All of the annotations are stripped out,
as well as the overloads, and all that is left is a very simple
JavaScript method:

#+begin_src js -n
  function add(x, y) {
      return x + y;
  }
#+end_src

#+cindex:rest parameters
TypeScript includes =rest= parameters, which is an unbounded list of
optional parameters.  The following code shows how to modify the ~add~
function to include a =rest= parameter:

#+begin_src js -n
  function add(arg1: string, ...args: string[]): string;
  function add(arg1: number, ...args: number[]): number;
  function add(arg1: any, ...args: any[]): any {
      var total = arg1;
      for (var i = 0; i < args.length; i++) {
          total += args[1];
      }
      return total;
  }
#+end_src

The TypeScript compiler generates an extra bit of JavaScript code to
generate a shifted array from the JavaScript =arguments= object that
is available to code inside of the function.

#+begin_src js -n
  function add(arg1) {
      var args = [];
      for (var _i = 0; _i < (arguments.length - 1); _i++) {
          args[_i] = arguments[_i + 1];
      }
      var total = args1;
      for (var i = 0; i < args.length; i++) {
          total += args[i];
      }
      return total;
  }
#+end_src

Now adding numbers or strings together is very simple and completely
type-safe.  If you attempt to mix the different parameter types, a
compile error will occur.

** Function Types
#+cindex:function type
{{{heading(Typing the Function)}}}

Let’s add types to our simple examples from earlier:

#+begin_src js
function add(x: number, y: number): number {
    return x + y;
}

let myAdd = function(x: number, y: number): number { return x + y; };
#+end_src

We can add types to each of the parameters and then to the function
itself to add a return type.  TypeScript can figure the return type
out by looking at the return statements, so we can also optionally
leave this off in many cases.

{{{heading(Writing the Function Type)}}}

Let’s write the full type of the function out by looking at each piece
of the function type.

#+begin_src js
let myAdd: (x: number, y: number) => number =
    function(x: number, y: number): number { return x + y; };
#+end_src

A function’s type has the same two parts: the type of the arguments
and the return type.  When writing out the whole function type, both
parts are required.

{{{subheading(Parameter Types)}}}

We write out the parameter types just like a parameter list, giving
each parameter a name and a type.  This name is just to help with
readability.  We could have instead written:

#+begin_src js
let myAdd: (baseValue: number, increment: number) => number =
    function(x: number, y: number): number { return x + y; };
#+end_src

As long as the parameter types line up, it’s considered a valid type
for the function, regardless of the names you give the parameters in
the function type.

{{{subheading(Return Type)}}}

The second part is the return type.  We make it clear which is the
return type by using a fat arrow (~=>~) between the parameters and the
return type.  As mentioned before, this is a required part of the
function type, so if the function doesn’t return a value, you would
use =void= instead of leaving it off.

#+cindex:captured variables
#+cindex:hidden state
Of note, only the parameters and the return type make up the function
type.  Captured variables are not reflected in the type.  In effect,
captured variables are part of the “hidden state” of any function and
do not make up its API.

{{{heading(Inferring the Types)}}}

In playing with the example, you may notice that the TypeScript
compiler can figure out the type even if you only have types on one
side of the equation:

#+begin_src js
// myAdd has the full function type
let myAdd = function(x: number, y: number): number { return  x + y; };

// The parameters 'x' and 'y' have the type number
let myAdd: (baseValue: number, increment: number) => number =
    function(x, y) { return x + y; };
#+end_src

#+cindex:contextual typing
#+cindex:type inference
This is called “contextual typing”, a form of type inference.  This
helps cut down on the amount of effort to keep your program typed.

** Optional and Default Parameters
In TypeScript, every parameter is assumed to be required by the
function.  This doesn’t mean that it can’t be given null or undefined,
but rather, when the function is called, the compiler will check that
the user has provided a value for each parameter.  The compiler also
assumes that these parameters are the only parameters that will be
passed to the function.  In short, the number of arguments given to a
function has to match the number of parameters the function expects.

#+begin_src js
function buildName(firstName: string, lastName: string) {
    return firstName + " " + lastName;
}

let result1 = buildName("Bob");                  // error, too few parameters
let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result3 = buildName("Bob", "Adams");         // ah, just right
#+end_src

In JavaScript, every parameter is optional, and users may leave them
off as they see fit.  When they do, their value is =undefined=.  We
can get this functionality in TypeScript by adding a =?= to the end of
parameters we want to be optional.  For example, let’s say we want the
last name parameter from above to be optional:

#+begin_src js
function buildName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + " " + lastName;
    else
        return firstName;
}

let result1 = buildName("Bob");                  // works correctly now
let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result3 = buildName("Bob", "Adams");         // ah, just right
#+end_src

Any optional parameters must follow required parameters.  Had we
wanted to make the first name optional, rather than the last name, we
would need to change the order of parameters in the function, putting
the first name last in the list.

#+cindex:default-initialized parameter
In TypeScript, we can also set a value that a parameter will be
assigned if the user does not provide one, or if the user passes
undefined in its place.  These are called default-initialized
parameters.  Let’s take the previous example and default the last name
to "Smith".

#+begin_src js
function buildName(firstName: string, lastName = "Smith") {
    return firstName + " " + lastName;
}

let result1 = buildName("Bob");                  // works correctly now, returns "Bob Smith"
let result2 = buildName("Bob", undefined);       // still works, also returns "Bob Smith"
let result3 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result4 = buildName("Bob", "Adams");         // ah, just right
#+end_src

Default-initialized parameters that come after all required parameters
are treated as optional, and just like optional parameters, can be
omitted when calling their respective function. This means optional
parameters and trailing default parameters will share commonality in
their types, so both:

#+begin_src js
function buildName(firstName: string, lastName?: string) {
    // ...
}
#+end_src

and

#+begin_src js
function buildName(firstName: string, lastName = "Smith") {
    // ...
}
#+end_src

{{{noindent}}}share the same type =(firstName: string, lastName?:
string) => string=.  The default value of =lastName= disappears in the
type, only leaving behind the fact that the parameter is optional.

Unlike plain optional parameters, default-initialized parameters don’t
need to occur after required parameters.  If a default-initialized
parameter comes before a required parameter, users need to explicitly
pass =undefined= to get the default initialized value.  For example,
we could write our last example with only a default initializer on
=firstName=:

#+begin_src js
function buildName(firstName = "Will", lastName: string) {
    return firstName + " " + lastName;
}

let result1 = buildName("Bob");                  // error, too few parameters
let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result3 = buildName("Bob", "Adams");         // okay and returns "Bob Adams"
let result4 = buildName(undefined, "Adams");     // okay and returns "Will Adams"
#+end_src

** Rest Parameters
#+cindex:rest parameters
Required, optional, and default parameters all have one thing in
common: they talk about one parameter at a time.  Sometimes, you want
to work with multiple parameters as a group, or you may not know how
many parameters a function will ultimately take.  In JavaScript, you
can work with the arguments directly using the ~arguments~ variable
that is visible inside every function body.

In TypeScript, you can gather these arguments together into a
variable:

#+begin_src js
function buildName(firstName: string, ...restOfName: string[]) {
    return firstName + " " + restOfName.join(" ");
}

// employeeName will be "Joseph Samuel Lucas MacKinzie"
let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");
#+end_src

Rest parameters are treated as a boundless number of optional
parameters.  When passing arguments for a rest parameter, you can use
as many as you want; you can even pass none.  The compiler will build
an array of the arguments passed in with the name given after the
ellipsis (=...=), allowing you to use it in your function.

The ellipsis is also used in the type of the function with rest
parameters:

#+begin_src js
function buildName(firstName: string, ...restOfName: string[]) {
    return firstName + " " + restOfName.join(" ");
}

let buildNameFun: (fname: string, ...rest: string[]) => string = buildName;
#+end_src

{{{heading(Rest Parameter Rules)}}}

Rest parameters allow calling code to specify zero or more arguments
of the specified type.  For the arguments to be correctly passed, rest
parameters must follow these rules:

- Only one rest parameter is allowed.

- The rest parameter must appear last in the parameter list.

- The type of a rest parameter must be an array type.


To declare a rest parameter, prefix the identifier with three periods
and ensure that the type annotation is an array type.  Your function
should expect to receive any number of arguments, including none.  if
you require that at least one argument is passed, you would need to
add a required parameter before the rest parameter to enforce this
minimum requirement.

** this in Function Declarations
TypeScript lets you catch incorrect uses of this with a couple of
techniques.

{{{this and Arrow Functions)}}}

In JavaScript, ~this~ is a variable that’s set when a function is
called.  This makes it a very powerful and flexible feature, but it
comes at the cost of always having to know about the context that a
function is executing in.  This is notoriously confusing, especially
when returning a function or passing a function as an argument.

Let’s look at an example:

#+begin_src js
let deck = {
    suits: ["hearts", "spades", "clubs", "diamonds"],
    cards: Array(52),
    createCardPicker: function() {
        return function() {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
#+end_src

Notice that ~createCardPicker~ is a function that itself returns a
function.  If we tried to run the example, we would get an error
instead of the expected alert box.  This is because the ~this~ being
used in the function created by ~createCardPicker~ will be set to
=window= instead of our =deck= object.  That’s because we call
~cardPicker()~ on its own.  A top-level non-method syntax call like
this will use =window= for this.  (Note: under strict mode, this will
be =undefined= rather than window).

We can fix this by making sure the function is bound to the correct
~this~ before we return the function to be used later.  This way,
regardless of how it’s later used, it will still be able to see the
original =deck= object.  To do this, we change the function expression
to use the ECMAScript 6 arrow syntax.  Arrow functions capture the
~this~ where the function is created rather than where it is invoked:

#+begin_src js
let deck = {
    suits: ["hearts", "spades", "clubs", "diamonds"],
    cards: Array(52),
    createCardPicker: function() {
        // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here
        return () => {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
#+end_src

Even better, TypeScript will warn you when you make this mistake if
you pass the {{{option(--noImplicitThis)}}} flag to the compiler.  It
will point out that this in ~this.suits[pickedSuit]~ is of type =any=.

{{{heading(this Parameters)}}}

Unfortunately, the type of ~this.suits[pickedSuit]~ is still =any=.
That’s because ~this~ comes from the function expression inside the
object literal.  To fix this, you can provide an explicit ~this~
parameter.  ~this~ parameters are fake parameters that come first in
the parameter list of a function:

#+begin_src js
function f(this: void) {
    // make sure `this` is unusable in this standalone function
}
#+end_src

Let’s add a couple of interfaces to our example above, =Card= and
=Deck=, to make the types clearer and easier to reuse:

#+begin_src js
interface Card {
    suit: string;
    card: number;
}
interface Deck {
    suits: string[];
    cards: number[];
    createCardPicker(this: Deck): () => Card;
}
let deck: Deck = {
    suits: ["hearts", "spades", "clubs", "diamonds"],
    cards: Array(52),
    // NOTE: The function now explicitly specifies that its callee must be of type Deck
    createCardPicker: function(this: Deck) {
        return () => {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
#+end_src

Now TypeScript knows that ~createCardPicker~ expects to be called on a
=Deck= object.  That means that ~this~ is of type =Deck= now, not
=any=, so {{{option(--noImplicitThis)}}} will not cause any errors

{{{heading(this Parameters in Callbacks)}}}

You can also run into errors with ~this~ in callbacks, when you pass
functions to a library that will later call them.  Because the library
that calls your callback will call it like a normal function, this
will be =undefined=.  With some work you can use ~this~ parameters to
prevent errors with callbacks too.  First, the library author needs to
annotate the callback type with ~this~:

#+begin_src js
interface UIElement {
    addClickListener(onclick: (this: void, e: Event) => void): void;
}
#+end_src

~this: void~ means that ~addClickListener~ expects ~onclick~ to be a
function that does not require a ~this~ type.  Second, annotate your
calling code with ~this~:

#+begin_src js
class Handler {
    info: string;
    onClickBad(this: Handler, e: Event) {
        // oops, used `this` here. using this callback would crash at runtime
        this.info = e.message;
    }
}
let h = new Handler();
uiElement.addClickListener(h.onClickBad); // error!
#+end_src

With ~this~ annotated, you make it explicit that ~onClickBad~ must be
called on an instance of =Handler.  Then TypeScript will detect that
~addClickListener~ requires a function that has ~this: void~.  To fix
the error, change the type of ~this~:

#+begin_src js
class Handler {
    info: string;
    onClickGood(this: void, e: Event) {
        // can't use `this` here because it's of type void!
        console.log('clicked!');
    }
}
let h = new Handler();
uiElement.addClickListener(h.onClickGood);
#+end_src

Because ~onClickGood~ specifies its ~this~ type as =void=, it is legal
to pass to ~addClickListener~.  Of course, this also means that it
can’t use ~this.info~.  If you want both then you’ll have to use an
arrow function:

#+begin_src js
class Handler {
    info: string;
    onClickGood = (e: Event) => { this.info = e.message }
}
#+end_src

This works because arrow functions use the outer ~this~, so you can
always pass them to something that expects ~this: void~.  The downside
is that one arrow function is created per object of type =Handler=.
Methods, on the other hand, are only created once and attached to
=Handler= ’s prototype.  They are shared between all objects of type
=Handler=.

** Overloads
#+cindex:overload function method
JavaScript is inherently a very dynamic language.  It’s not uncommon
for a single JavaScript function to return different types of objects
based on the shape of the arguments passed in.

#+begin_src js
let suits = ["hearts", "spades", "clubs", "diamonds"];

function pickCard(x): any {
    // Check to see if we're working with an object/array
    // if so, they gave us the deck and we'll pick the card
    if (typeof x == "object") {
        let pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
    }
    // Otherwise just let them pick the card
    else if (typeof x == "number") {
        let pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
    }
}

let myDeck = [{ suit: "diamonds", card: 2 }, { suit: "spades", card: 10 }, { suit: "hearts", card: 4 }];
let pickedCard1 = myDeck[pickCard(myDeck)];
alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);

let pickedCard2 = pickCard(15);
alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
#+end_src

Here, the ~pickCard~ function will return two different things based
on what the user has passed in.  If the users passes in an object that
represents the deck, the function will pick the card.  If the user
picks the card, we tell them which card they’ve picked.  But how do we
describe this to the type system?

#+cindex:overload list
The answer is to supply multiple function types for the same function
as a list of overloads.  This list is what the compiler will use to
resolve function calls.

#+cindex:implementation signature
In many languages, each overload has its own implementation but in
TypeScript the overloads all decorate a single implementation.  The
actual signature of the function appears last and is hidden by the
overloads.  The final signature is called an /implementation
signature/.  The implementation signature must define parameters and a
return value that are compatible with all preceding signatures.  As
this implies, the return types for each overload can be different and
the parameter lists can differ not only in types, but also in number
of arguments. If an overload specifies fewer parameters than the
implementation signature, the implementation signature would have to
make the extra parameters optional, default, or rest parameters.

When you call a function that has overloads defined, the compiler
constructs a list of signatures and attempts to determine the
signature that matches the function call.  If there are no matching
signatures, the call results in an error.  If one or more signature
matches, the earliest of the matching signatures (in the order they
appear in the file) determines the return type.

Let’s create a list of overloads that describe what our ~pickCard~
accepts and what it returns.

#+begin_src js
let suits = ["hearts", "spades", "clubs", "diamonds"];

function pickCard(x: {suit: string; card: number; }[]): number;
function pickCard(x: number): {suit: string; card: number; };
function pickCard(x): any {
    // Check to see if we're working with an object/array
    // if so, they gave us the deck and we'll pick the card
    if (typeof x == "object") {
        let pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
    }
    // Otherwise just let them pick the card
    else if (typeof x == "number") {
        let pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
    }
}

let myDeck = [{ suit: "diamonds", card: 2 }, { suit: "spades", card: 10 }, { suit: "hearts", card: 4 }];
let pickedCard1 = myDeck[pickCard(myDeck)];
alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);

let pickedCard2 = pickCard(15);
alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
#+end_src

With this change, the overloads now give us type checked calls to the
~pickCard~ function.

In order for the compiler to pick the correct type check, it follows a
similar process to the underlying JavaScript.  It looks at the
overload list and, proceeding with the first overload, attempts to
call the function with the provided parameters.  If it finds a match,
it picks this overload as the correct overload.  For this reason, it’s
customary to order overloads from most specific to least specific.

Note that the function ~pickCard(x): any~ piece is not part of the
overload list, so it only has two overloads: one that takes an object
and one that takes a number.  Calling ~pickCard~ with any other
parameter types would cause an error.

{{{heading(Use Other Languages Features First Before Overloads)}}}

In most cases you can write a method using other TypeScript language
features such as optional, default, and rest parameter and avoid
writing an overload.  Where this isn’t possible, you should consider
writing separate, well-named functions that make their different
intentions explicit.  That isn’t to say that there are no valid uses
for function overloads and if you have considered the other options
and chosen to use overloads that is a perfectly reasonable selection.

*** Specialized Overload Signatures
Specialized overload signatures refer to the ability in TypeScript to
create overloads based on string constants.  Rather than the overloads
being based on different parameters, they are based on the string
value of an argument.  This allows a single implementation of a
function to be reused in many cases without requiring the calling code
to convert the types.

There are some rules to follow when using specialized overload
signatures:

- There must be at least one nonspecialized signature.

- Each specialized signature must return a subtype of a nonspecialized
  signature.

- The implementation signature must be compatible with all signatures.


The most common case for specialized signatures is that the
nonspecialized signature returns a superclass, with each overload
returning a more specialized subclass that inherits (or is
structurally compatible with) the superclass.

#+begin_src js -n
  class HandlerFactory {
  getHandler(type: 'Random'): RandomHandler;
  getHandler(type: 'Reversed'): ReversedHandler;
      getHandler(type: string): Handler; // non-specialized signature
      getHandler(type: string): Handler { // implementation signature
          switch (type) {
              case 'Random':
                  return new RandomHandler();
              case 'Reversed':
                  return new ReversedHandler();
              default:
          }
      }
  }
#+end_src

When you write signatures that satisfy these rules, you may find that
your implementation signature is identical to your nonspecialized
signature.  Remember that the implementation signature is hidden from
calling code, so although it looks like duplication, it is necessary.

This is how the classic definition for the Document Object Model (DOM)
method getElementsByTagName was declared in the early versions of the
TypeScript standard library, which means you get back an appropriately
typed NodeList depending on the HTML tag name you pass to the
function.

#+caption:getElementsByTagName
#+name:getElementsByTagName-example
#+begin_src js -n
  // This example does not list all variations...
  getElementsByTagName(name: "a"): NodeListOf<HTMLAnchorElement>;
  getElementsByTagName(name: "blockquote"): NodeListOf<HTMLQuoteElement>;
  getElementsByTagName(name: "body"): NodeListOf<HTMLBodyElement>;
  getElementsByTagName(name: "button"): NodeListOf<HTMLButtonElement>;
  getElementsByTagName(name: "form"): NodeListOf<HTMLFormElement>;
  getElementsByTagName(name: "h1"): NodeListOf<HTMLHeadingElement>;
  getElementsByTagName(name: string): NodeList; // Non-specialized signature
  getElementsByTagName(name: string): NodeList { // implementation signature
      return document.getElementsByTagName(name);
  }
#+end_src

The above shows how specialized subclasses are annotated as the return
type where a specific value is passed in the type parameter.  This is
an unusual technique, but is necessary for the purposes of defining
the behavior you would expect from web browsers.  The specialized
overloads inspect the value being passed and select the overload based
on that value, for example, if you pass a name argument with the value
"blockquote", the second signature above will be matched and the
return type is =NodeListOf<HTMLQuoteElement>=.

*** Arrow Functions

TypeScript provides shorthand syntax for defining a function.  The
arrow function is inspired by additions to the ECMAScript standard.
Arrow functions allow you to leave out the function keyword and define
your functions in an ultracompact way.  When you target ECMAScript 3
or 5, the arrow functions result in identical JavaScript functions in
the output.

#+begin_src js -n
  const shortAddNumbers = (a: number, b: number) => a + b;

  const mediumAddNumbers = (a: number, b: number) => {
      return a + b;
  }

  const longAddNumbers = function (a: number, b: number) {
      return a + b;
  }
#+end_src

{{{heading(Preserving this Scope Using Arrow Functions)}}}

You can also use an arrow syntax to preserve the lexical scope of the
this keyword.  This is particularly useful when working with
callbacks, promises, or events as these represent situations where you
are likely to lose the current scope.

#+begin_src js -n
  const scopePreservingExample = {
      text: "Property from lexical scope",
      run: function () {
          setTimeout(() => {
              alert(this.text);
          }, 1000);
      }
  };
  // alerts "Property from lexical scope"
  scopePreservingExample.run();
#+end_src

Behind the scenes, the TypeScript compiler creates a variable named
~_this~ just before the arrow function is defined and sets its value
to the current value of ~this~.  It also substitutes any usages of
~this~ within the function with the newly introduced ~_this~ variable,
so the statement now reads ~_this.text~ in the JavaScript output.  The
use of the ~_this~ variable inside the function creates a closure
around the variable, which preserves its context along with the
function.

*** Function Currying

/Currying/ is a process whereby a function with multiple parameters is
decomposed into multiple functions that each take a single parameter.
The resulting chain of functions can be called in stages, with the
partly applied stage becoming a reusable implementation of the
combined function and value.

You can use arrow functions for function currying.

#+begin_src js -n
  // Currying
  const multiply = (a: number) => (b: number) => a * b;

  // Pass both arguments in sequence: 30
  const numA = multiply(5)(6);

  // Pass just the first argument and re-use
  const orderOfMagnitude = multiply(10);

  // 10
  const deca = orderOfMagnitude(1);

  // 100
  const hecta = orderOfMagnitude(deca);

  // 1,000
  const kilo = orderOfMagnitude(hecta);
#+end_src

The first function takes a single parameter named ~a~, and returns
another function that has captured the value of the original argument.
The function that is returned accepts a single parameter named ~b~,
and when called returns the product of ~a~ and ~b~.  You can hold onto
the result of the first function call and use it many times, which is
one of the key points of currying.

Here is a practical example.  Instead of repeating the first argument
of a logging function, it can be specified a single time and applied
each time the logging function is called. This reduces repetition and
improves readability.

#+caption:Custom Logging Using Currying
#+name:custom-logging-using-currying
#+begin_src js -n
  const log = (source: string) => (message: string) => console.log(source, message);

  const customLog = log('Custom Log:');

  // Custom Log: Message One
  customLog('Message One');

  // Custom Log: Message Two
  customLog('Message Two');
#+end_src

* Interfaces
Interfaces are a way of representing complex types about any object.
They have absolutely no runtime consequences because JavaScript does
not include any sort of runtime type checking.  Interfaces are
analyzed at compile time and then omitted from the resulting
JavaScript.  Interfaces create a contract for developers to use when
developing new objects or writing methods to interact with existing
ones.  Interfaces are named types that contain a list of members.

** Example of a Simple Interface and Inheritance
Here is an example of a simple interface:

#+begin_src js -n
  interface IPoint {
      x: number;
      y: number;
  }
#+end_src

You use the ~interface~ keyword to start the interface declaration.
Then you give the interface a name to reference the code.

A simple naming convention can improve the readability of code when
using interfaces.  Interfaces can be given the format ~I<name>~ and
object types just use the ~<name>~, e.g., ~IFoo~ and ~Foo~.

The interface's declaration body contains just a list of members and
functions and their types.  Interface members can only be instance
members of an object.

Interfaces have the ability to inherit from base types.  This
interface inheritance allows interfaces to be extended from existing
interfaces into a more enhanced version as well as merge separate
interfaces together.  To create an inheritance chain, interfaces use
the ~extends~ clause.  The ~extends~ clause is followed by a
comma-separated list of types that the interface will merge with.

: interface IFoo extends IBar, IQuux { body }

Interfaces can be referenced in code as type parameters or type
declarations.  Further, interface declarations are open-ended and will
implicitly merge together if they have the same if they have the same
type name.  The TypeScript compiler also implements a duck typing
system that allows you to create objects on the fly while keeping type
safety.

** Interface Introduction and Duck Typing
#+cindex:interfaces, introduction
#+cindex:duck typing
#+cindex:structural subtyping
One of TypeScript’s core principles is that type checking focuses on
the shape that values have.  This is sometimes called “duck typing” or
“structural subtyping”.  In TypeScript, interfaces fill the role of
naming these types, and are a powerful way of defining contracts
within your code as well as contracts with code outside of your
project.

{{{heading(A Simple Interface)}}}

#+begin_src js
function printLabel(labeledObj: { label: string }) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
#+end_src

The type checker checks the call to ~printLabel~.  The ~printLabel~
function has a single parameter that requires that the object passed
in has a property called =label= of type =string=.  Notice that our
object actually has more properties than this, but the compiler only
checks that at least the ones required are present and match the types
required.

We can write the same example again, this time using an interface to
describe the requirement of having the =label= property that is a
=string=:

#+begin_src js
interface LabeledValue {
    label: string;
}

function printLabel(labeledObj: LabeledValue) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
#+end_src

The interface =LabeledValue= is a name we can now use to describe the
requirement in the previous example.  It still represents having a
single property called =label= that is of type =string=.  Notice we
didn’t have to explicitly say that the object we pass to ~printLabel~
implements this interface like we might have to in other languages.
Here, it’s only the shape that matters.  If the object we pass to the
function meets the requirements listed, then it’s allowed.

It’s worth pointing out that the type checker does not require that
these properties come in any sort of order, only that the properties
the interface requires are present and have the required type.

** Optional Properties
#+cindex:interface, optional property
#+cindex:option bag
Not all properties of an interface may be required.  Some exist under
certain conditions or may not be there at all.  These optional
properties are popular when creating patterns like “option bags” where
you pass an object to a function that only has a couple of properties
filled in.

Here’s an example of this pattern:

#+caption:Example of an Interface with optional Properties
#+name:interface-with-optional-properties
#+begin_src js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    let newSquare = {color: "white", area: 100};
    if (config.color) {
        newSquare.color = config.color;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
#+end_src

Interfaces with optional properties are written similar to other
interfaces, with each optional property denoted by a =?= at the end of
the property name in the declaration.

The advantage of optional properties is that you can describe these
possibly available properties while still also preventing use of
properties that are not part of the interface.  For example, had we
mistyped the name of the color property in ~createSquare~, we would get
an error message letting us know:

#+begin_src js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    let newSquare = {color: "white", area: 100};
    if (config.clor) {
        // Error: Property 'clor' does not exist on type 'SquareConfig'
        newSquare.color = config.clor;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
#+end_src

** Read-Only Properties
Some properties should only be modifiable when an object is first
created.  You can specify this by putting =readonly= before the name
of the property:

#+begin_src js
interface Point {
    readonly x: number;
    readonly y: number;
}
#+end_src

You can construct a Point by assigning an object literal. After the
assignment, x and y can’t be changed.

#+begin_src js
let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
#+end_src

TypeScript comes with a =ReadonlyArray<T>= type that is the same as
=Array<T>= with all mutating methods removed, so you can make sure you
don’t change your arrays after creation:

#+begin_src js
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
#+end_src

On the last line of the snippet you can see that even assigning the
entire =ReadonlyArray= back to a normal array is illegal.  You can
still override it with a type assertion, though:

#+begin_src js
a = ro as number[];
#+end_src

The easiest way to remember whether to use =readonly= or =const= is to
ask whether you’re using it on a variable or a property.  Variables
use =const= whereas properties use =readonly=.
** Excess Property Checks
In our first example using interfaces, TypeScript lets us pass ={
size: number; label: string; }= to something that only expected a ={
label: string; }=.  We also just learned about optional properties,
and how they’re useful when describing so-called “option bags”.

However, combining the two naively would allow an error to sneak
in.  For example, taking our last example using ~createSquare~:

#+begin_src js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}

let mySquare = createSquare({ colour: "red", width: 100 });
#+end_src

Notice the given argument to ~createSquare~ is spelled =colour= instead of
=color=.  In plain JavaScript, this sort of thing fails silently.

You could argue that this program is correctly typed, since the
=width= properties are compatible, there’s no =color= property
present, and the extra =colour= property is insignificant.

However, TypeScript takes the stance that there’s probably a bug in
this code.  Object literals get special treatment and undergo /excess
property checking/ when assigning them to other variables, or passing
them as arguments.  If an object literal has any properties that the
“target type” doesn’t have, you’ll get an error:

#+begin_src js
// error: Object literal may only specify known properties, but
// 'colour' does not exist in type 'SquareConfig'. Did you mean to
// write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });
#+end_src

#+cindex:type assertion
Getting around these checks is actually really simple.  The easiest
method is to just use a /type assertion/:

#+begin_src js
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
#+end_src

However, a better approach might be to add a /string index signature/
if you’re sure that the object can have some extra properties that are
used in some special way.  If =SquareConfig= can have =color= and
=width= properties with the above types, but could also have any
number of other properties, then we could define it like so:

#+begin_src js
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
#+end_src

Here we’re saying a =SquareConfig= can have any number of properties,
and as long as they aren’t =color= or =width=, their types don’t
matter.

One final way to get around these checks, which might be a bit
surprising, is to assign the object to another variable: Since
~squareOptions~ won’t undergo excess property checks, the compiler
won’t give you an error.

#+begin_src js
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
#+end_src

The above workaround will work as long as you have a common property
between ~squareOptions~ and =SquareConfig=.  In this example, it was
the property =width=.  It will however, fail if the variable does not
have any common object property.  For example:

#+begin_src js
let squareOptions = { colour: "red" };
let mySquare = createSquare(squareOptions);
#+end_src

Keep in mind that for simple code like above, you probably shouldn’t
be trying to “get around” these checks.  For more complex object
literals that have methods and hold state, you might need to keep
these techniques in mind, but a majority of excess property errors are
actually bugs.  That means if you’re running into excess property
checking problems for something like option bags, you might need to
revise some of your type declarations.  In this instance, if it’s okay
to pass an object with both a =color= or =colour= property to
~createSquare~, you should fix up the definition of =SquareConfig= to
reflect that.
** Function Types
#+cindex:interfaces and function types
#+cindex:funtion types, and interfaces
Interfaces are capable of describing the wide range of shapes that
JavaScript objects can take.  In addition to describing an object with
properties, interfaces are also capable of describing function types.

#+cindex:call signature
To describe a function type with an interface, we give the interface a
/call signature/.  This is like a function declaration with only the
parameter list and return type given.  Each parameter in the parameter
list requires both name and type.

#+begin_src js
interface SearchFunc {
    (source: string, subString: string): boolean;
}
#+end_src

Once defined, we can use this function type interface like we would
other interfaces.  Here, we show how you can create a variable of a
function type and assign it a function value of the same type.

#+begin_src js
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    let result = source.search(subString);
    return result > -1;
}
#+end_src

For function types to correctly type check, the names of the
parameters do not need to match.  We could have, for example, written
the above example like this:

#+begin_src js
let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
    let result = src.search(sub);
    return result > -1;
}
#+end_src

#+cindex:contextual typing
#+cindex:inference, type
#+cindex:type inference
Function parameters are checked one at a time, with the type in each
corresponding parameter position checked against each other.  If you
do not want to specify types at all, TypeScript’s /contextual typing/
can /infer/ the argument types since the function value is assigned
directly to a variable of type =SearchFunc=.  Here, also, the return
type of our function expression is implied by the values it returns
(here =false= and =true=).  Had the function expression returned
=numbers= or =strings=, the type checker would have warned us that
return type doesn’t match the return type described in the
=SearchFunc= interface.

#+begin_src js
let mySearch: SearchFunc;
mySearch = function(src, sub) {
    let result = src.search(sub);
    return result > -1;
}
#+end_src

** Indexable Types
#+cindex:indexable types
#+cindex:types, indexable
#+cindex:interface for indexable type
#+cindex:index signature
Similarly to how we can use interfaces to describe function types, we
can also describe types that we can “index into” like ~a[10]~, or
~ageMap["daniel"]~.  Indexable types have an index signature that
describes the types we can use to index into the object, along with
the corresponding return types when indexing.  Let’s take an example:

#+begin_src js
interface StringArray {
    [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];
#+end_src

Above, we have a =StringArray= interface that has an index signature.
This index signature states that when a =StringArray= is indexed with
a =number=, it will return a =string=.

There are two types of supported index signatures: =string= and
=number=.  It is possible to support both types of indexers, /but the
type returned from a numeric indexer must be a subtype of the type
returned from the string indexer/.  This is because when indexing with
a =number=, JavaScript will actually convert that to a =string= before
indexing into an object.  That means that indexing with =100= (a
=number=) is the same thing as indexing with "100" (a =string=), so
the two need to be consistent.

#+begin_src js
class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

// Error: indexing with a numeric string might get you a completely separate type of Animal!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}
#+end_src

While string index signatures are a powerful way to describe the
“dictionary” pattern, /they also enforce that all properties match
their return type/.  This is because a string index declares that
=obj.property= is also available as =obj["property"]=.  In the
following example, =name= ’s type does not match the string index’s
type, and the type checker gives an error:

#+begin_src js
interface NumberDictionary {
    [index: string]: number;
    length: number;    // ok, length is a number
    name: string;      // error, the type of 'name' is not a subtype of the indexer
}
#+end_src

#+cindex:union
However, properties of different types are acceptable if the index
signature is a union of the property types:

#+begin_src js
interface NumberOrStringDictionary {
    [index: string]: number | string;
    length: number;    // ok, length is a number
    name: string;      // ok, name is a string
#+end_src

Finally, you can make index signatures =readonly= in order to prevent
assignment to their indices:

#+begin_src js
interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // error!
#+end_src

You can’t set ~myArray[2]~ because the index signature is =readonly=.

** Class Types
#+cindex:class types
#+cindex:interface, class
One of the most common uses of interfaces in languages like C# and
Java, that of explicitly enforcing that a class meets a particular
contract, is also possible in TypeScript.

#+begin_src js
interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date = new Date();
    constructor(h: number, m: number) { }
}
#+end_src

You can also describe methods in an interface that are implemented in
the class, as we do with ~setTime~ in the below example:

#+begin_src js
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date): void;
}

class Clock implements ClockInterface {
    currentTime: Date = new Date();
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
#+end_src

#+cindex:public interface
#+cindex:private interface
Interfaces describe the public side of the class, rather than both the
public and private side.  This prohibits you from using them to check
that a class also has particular types for the private side of the
class instance.

*** Static vs Instance
#+cindex:static side
#+cindex:instance side
#+cindex:construct signature
When working with classes and interfaces, it helps to keep in mind
that a class has two types: the type of the static side and the type
of the instance side.  You may notice that if you create an interface
with a construct signature and try to create a class that implements
this interface you get an error:

#+begin_src js
interface ClockConstructor {
    new (hour: number, minute: number);
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
#+end_src

This is because when a class implements an interface, only the
instance side of the class is checked.  Since the constructor sits in
the static side, it is not included in this check.

#+cindex:constructor function
Instead, you would need to work with the static side of the class
directly.  In this example, we define two interfaces,
=ClockConstructor= for the constructor and =ClockInterface= for the
instance methods.  Then, for convenience, we define a constructor
function ~createClock~ that creates instances of the type that is
passed to it:

#+caption:Interface for Constructor Function
#+name:interface-for-constructor-function
#+begin_src js -n
interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    tick(): void;
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("beep beep");
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("tick tock");
    }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
#+end_src

Because ~createClock~ ’s first parameter is of type
=ClockConstructor=, in ~createClock(AnalogClock, 7, 32)~, it checks
that =AnalogClock= has the correct constructor signature.

#+cindex:class expression
Another simple way is to use class expressions:

#+begin_src js
interface ClockConstructor {
  new (hour: number, minute: number);
}

interface ClockInterface {
  tick();
}

const Clock: ClockConstructor = class Clock implements ClockInterface {
  constructor(h: number, m: number) {}
  tick() {
      console.log("beep beep");
  }
}
#+end_src

** Hybrid Types
You can also describe hybrid types with an interface, such as a
function/object hybrid type.  

#+caption:Hybrid Type
#+name:hybrid-type
#+begin_src js -n
  // Hybrid type
  interface SimpleDocument {
      (selector: string): HTMLElement;
      notify(message: string): void;
  }

  // Implementation
  const prepareDocument = function (): SimpleDocument {
      let doc = <SimpleDocument>function (selector: string) {
          return document.getElementById(selector);
      };

      doc.notify = function (message: string) {
          alert(message);
      }

      return doc;
  }

  const $ = prepareDocument();

  // Call $ as a function
  const elem = $('myId');

  // Use $ as an object
  $.notify(elem.id);
#+end_src

** Extending Interfaces
#+cindex:interface, extend
Like classes, interfaces can extend each other.  This allows you to
copy the members of one interface into another, which gives you more
flexibility in how you separate your interfaces into reusable
components.

#+begin_src js
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = {} as Square;
square.color = "blue";
square.sideLength = 10;
#+end_src

An interface can extend multiple interfaces, creating a combination of
all of the interfaces.

#+begin_src js
interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = {} as Square;
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
#+end_src

** Hybrid Types
Interfaces can describe the rich types present in real world
JavaScript.  Because of JavaScript’s dynamic and flexible nature, you
may occasionally encounter an object that works as a combination of
some of the types described above.

One such example is an object that acts as both a function and an
object, with additional properties:

#+begin_src js
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = (function (start: number) { }) as Counter;
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
#+end_src

When interacting with 3rd-party JavaScript, you may need to use
patterns like the above to fully describe the shape of the type.

** Interfaces Extending Classes
When an interface type extends a class type it inherits the members of
the class but not their implementations.  It is as if the interface
had declared all of the members of the class without providing an
implementation.  Interfaces inherit even the private and protected
members of a base class.  This means that when you create an interface
that extends a class with private or protected members, that interface
type can only be implemented by that class or a subclass of it.

This is useful when you have a large inheritance hierarchy, but want
to specify that your code works with only subclasses that have certain
properties. The subclasses don’t have to be related besides inheriting
from the base class. For example:

#+begin_src js
class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class TextBox extends Control {
    select() { }
}

// Error: Property 'state' is missing in type 'Image'.
class Image implements SelectableControl {
    private state: any;
    select() { }
}

class Location {

}
#+end_src

In the above example, =SelectableControl= contains all of the members
of =Control=, including the =private= =state= property.  Since =state=
is a private member it is only possible for descendants of =Control=
to implement =SelectableControl=.  This is because only descendants of
=Control= will have a =state= =private= member that originates in the
same declaration, which is a requirement for private members to be
compatible.

Within the =Control= class it is possible to access the =state=
=private= member through an instance of =SelectableControl=.
Effectively, a =SelectableControl= acts like a =Control= that is known
to have a select method.  The =Button= and =TextBox= classes are
subtypes of =SelectableControl= (because they both inherit from
=Control= and have a =select= method), but the =Image= and =Location=
classes are not.
* Classes
Classes consist of a variety of different properties and members.
These members can be either public or private, and static or instance.

** Class Constructors
#+cindex:constructors
All classes in TypeScript have a constructor, whether you specify one
or not.  If you leave out the constructor, the compiler will
automatically add one.

For a class that doesn’t inherit from another class, the automatic
constructor will be parameterless and will initialize any class
properties.  Where the class extends another class, the automatic
constructor will match the superclass signature and will pass
arguments to the superclass before initializing any of its own
properties.

If you prefix a constructor parameter with an access modifier, such as
=private=, it will automatically be mapped for you.  You can refer to
these constructor parameters as if they were declared as properties on
the class;

** Class and Instance Properties and Methods

*** Instance Properties
#+cindex:instance properties
Instance properties are typically declared before the constructor in a
TypeScript class.  A property definition consists of two to four parts:

- an optional access modifier;
- the identifier;
- a type annotation
- You can also initialize the property with a value


: public name: string = "John";

When your program is compiled, the property initializers are moved
into the top of the constructor, so they run before any code you place
in the constructor.

Instance properties can be accessed from within the class using the
~this~ keyword.  If the property is public it can be accessed using
the instance name.

*** Static Properties
#+cindex:static properties
You can also add static properties to your class, which are defined in
the same way as instance properties, but with the ~static~ keyword
between the access modifier (if one is specified) and the identifier.
Static properties are accessed using the class name; this is because
the property is not defined on each instance.

#+begin_src js -n
  static Compare(p1: Point, p2: Point): number {
      return p1.Compare(p2);
  }
#+end_src

This ~Compare~ method is put directly on the =Point= object being
created:

#+begin_src js -n
  var Point = (function () {
      function Point(x, y) {
	  ...
      }
      Point.prototype.Compare = function(p2) {
	  ...
      }
      Point.Compare = function(p1, p2) {
	  return p1.Compare(p2);
      }
      return Point;
  })();
#+end_src

In this example, we use =static= on the origin, as it’s a general
value for all grids.  Each instance accesses this value through
prepending the name of the class.  Similarly to prepending ~this~ in
front of instance accesses, here we prepend =Grid.= in front of static
accesses.

#+begin_src js
class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        let xDist = (point.x - Grid.origin.x);
        let yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

let grid1 = new Grid(1.0);  // 1x scale
let grid2 = new Grid(5.0);  // 5x scale

console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
#+end_src

*** Read-Only Properties
#+cindex:readonly properties
You can make both static and instance properties read-only to prevent
the values being overwritten.

#+cindex:@code{readonly} keyword
#+cindex:property, @code{readonly}
You can make properties =readonly= by using the =readonly= keyword.
=Readonly= properties must be initialized at their declaration or in
the constructor.

#+begin_src js
class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus("Man with the 8 strong legs");
dad.name = "Man with the 3-piece suit"; // error! name is readonly.
#+end_src

{{{heading(Parameter Properties)}}}

#+cindex:parameter property
In our last example, we had to declare a =readonly= member =name= and
a constructor parameter =theName= in the =Octopus= class.  This is
needed in order to have the value of =theName= accessible after the
=Octopus= constructor is executed.  Parameter properties let you create
and initialize a member in one place.  Here’s a further revision of the
previous =Octopus= class using a parameter property:

#+begin_src js
class Octopus {
    readonly numberOfLegs: number = 8;
    constructor(readonly name: string) {
    }
}
#+end_src

Notice how we dropped =theName= altogether and just use the shortened
=readonly= =name: string= parameter on the constructor to create and
initialize the =name= member.  We’ve consolidated the declarations and
assignment into one location.

Parameter properties are declared by prefixing a constructor parameter
with an accessibility modifier or =readonly=, or both.  Using
=private= for a parameter property declares and initializes a
=private= member; likewise, the same is done for =public=,
=protected=, and =readonly=.

*** Instance Member Functions
#+cindex:methods
Methods are defined a lot like functions, but they leave out the
~function~ keyword.  You can annotate a method with all the parameters
and return value type annotations that were discussed earlier in the
section on functions.  You can prefix the method name with an access
modifier to control its visibility, which is public by default.  Just
as with instance properties, methods can be accessed from within the
class using the ~this~ keyword; and if they are public they can be
accessed outside of the class using the instance name.

You can create static methods by prefixing the method name with the
~static~ keyword.  Static members can be called even when no instance
of the class has been created and only a single instance of each
static member exists in your program.  All static members are accessed
via the class name and not an instance name and static members have no
access to nonstatic properties or methods.

#+cindex:instance member methods
Instance member functions are only available to an instance of the
object of the type and they have access to the ~this~ object that
allows easy access to all of an object's members.  In JavaScript there
are a couple of ways to create instance member functions: they can be
added directly to the object using the ~this~ object during the
object's creation, or they can be attached to the object's prototype.
TypeScript has adopted the latter method.

In the following code, an interface is created which includes an
instance member function, or method, and a class is implemented based
upon this interface.  The class does not include a constructor, but it
does include default values for the instance members.  Below the class
definition is a representation of the transpiled JavaScript code.
This code is given a constructor that initializes the instance members
using the default parameter values, and places the method on the
constructor's prototype.

#+begin_src js -n
  interface IBounds {
      Location: IPoint;
      Height: number;
      Width: number;
      Size(): number;
  }

  class Bounds implements IBound {
      public Location: IPoint = new Point(0, 0);
      public Height: number = 0;
      public Width: number = 0;
      public Size() {
          return this.Height * this.Width;
      }
  }

  var Bounds = (function () {
      function Bounds() {
          this.Location = new Point(0, 0);
          this.Height = 0;
          this.Width = 0;
      }
      Bounds.prototype.Size = function () {
          return this.Height * this.Width;
      }
      return Bounds;
      })();
#+end_src

*** Access Modifiers

#+cindex:access modifiers
#+cindex:private
#+cindex:protected
#+cindex:pubic
Access modifiers are a key component of encapsulation.  Access
modifiers change the visibility of class members.  There are three
access modifiers available in TypeScript:

- private :: The =private= modifier restricts the visibility to the
             same-class only.  When you use the =private= modifier on
             a member, it won’t appear in autocompletion (which is a
             strong hint that you can’t use it) and attempts to access
             the member from outside the class will result in a
             compiler error.  You cannot even access the member from a
             subclass.

- protected :: The =protected= modifier allows the member to be used
               within the same-class, and within subclasses.  Access
               from anywhere else is not allowed.

- public :: The =public= modifier, which is the default for class
            members, allows access from all locations.  It is not
            necessary to specify the =public= keyword on a property or
            method unless you want to be explicit --- but you will
            need to add it to constructor parameters to have them
            mapped to properties automatically.

{{{heading(Public by Default)}}}

In our examples, we’ve been able to freely access the members that we
declared throughout our programs.  If you’re familiar with classes in
other languages, you may have noticed in the above examples we haven’t
had to use the word =public= to accomplish this; for instance, C#
requires that each member be explicitly labeled =public= to be
visible.  In TypeScript, each member is =public= by default.

You may still mark a member =public= explicitly.  We could have
written the =Animal= class from the previous section in the following
way:

#+begin_src js
class Animal {
    public name: string;
    public constructor(theName: string) { this.name = theName; }
    public move(distanceInMeters: number) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}
#+end_src

{{{heading(Understanding Private)}}}

When a member is marked private, it cannot be accessed from outside of
its containing class.  For example:

#+begin_src js
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal("Cat").name; // Error: 'name' is private;
#+end_src

#+cindex:structural type system
#+cindex:type system, structural
TypeScript is a /structural type system/.  When we compare two
different types, regardless of where they came from, if the types of
all members are compatible, then we say the types themselves are
compatible.

However, when comparing types that have =private= and =protected=
members, we treat these types differently.  For two types to be
considered compatible, if one of them has a =private= member, then the
other must have a =private= member that originated in the same
declaration.  The same applies to =protected= members.

Let’s look at an example to better see how this plays out in practice:

#+begin_src js
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super("Rhino"); }
}

class Employee {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

let animal = new Animal("Goat");
let rhino = new Rhino();
let employee = new Employee("Bob");

animal = rhino;
animal = employee; // Error: 'Animal' and 'Employee' are not compatible
#+end_src

In this example, we have an =Animal= and a =Rhino=, with =Rhino= being
a subclass of =Animal=.  We also have a new class =Employee= that
looks identical to =Animal= in terms of shape.  We create some
instances of these classes and then try to assign them to each other
to see what will happen.  Because =Animal= and =Rhino= share the
private side of their shape from the same declaration of =private=
=name=: =string= in =Animal=, they are compatible. n However, this is
not the case for =Employee.  When we try to assign from an =Employee=
to =Animal= we get an error that these types are not compatible.  Even
though =Employee= also has a =private= member called =name=, it’s not
the one we declared in =Animal=.

{{{heading(Understanding Protected)}}}

The =protected= modifier acts much like the =private= modifier with
the exception that members declared =protected= can also be accessed
within deriving classes.  For example,

#+begin_src js
class Person {
    protected name: string;
    constructor(name: string) { this.name = name; }
}

class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee("Howard", "Sales");
console.log(howard.getElevatorPitch());
console.log(howard.name); // error
#+end_src

Notice that while we can’t use =name= from outside of =Person=, we can
still use it from within an instance method of =Employee= because
=Employee= derives from =Person=.

A constructor may also be marked protected. This means that the class
cannot be instantiated outside of its containing class, but can be
extended. For example,

#+begin_src js
class Person {
    protected name: string;
    protected constructor(theName: string) { this.name = theName; }
}

// Employee can extend Person
class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee("Howard", "Sales");
let john = new Person("John"); // Error: The 'Person' constructor is protected
#+end_src

*** Property Accessors
#+cindex:Properties
#+cindex:ECMAScript 5
#+cindex:getter
#+cindex:setter
#+cindex:@code{get} keyword
#+cindex:@code{set} keyword
The concept of =Properties= was introduced in ECMAScript 5.  This
allows a developer to create getter and setter methods for a
designated instance method that can be accessed like properties.  The
TypeScript compiler must be set to emit ECMAScript 5 code, and then
you will be able to use the =get= and =set= keywords to define
properties.  Since getters and setters are method calls, they allow
the programmer to verify constraints placed on instance members.

TypeScript supports property getters and setters, if you are targeting
ECMAScript 5 or above.  The syntax for these is identical to method
signatures as described in the following, except they are prefixed by
either the ~get~ or ~set~ keyword.  Property getters and setters allow
you to wrap property access with a method while preserving the
appearance of a simple property to the calling code.

#+begin_src js -n
  interface IBounds {
      Location: IPoint;
      Height: number;
      Width: number;
      Size(): number;
  }

  class Bounds implements IBounds {
      public Location: IPoint = new Point(0, 0);
      private _height: number = 0;
      private _width: number = 0;
      public Size() {
          return this.Height * this.Width;
      }
      get Height(): number {
          return this._height;
      }
      set Height(value: number) {
          this._height = (value > 0) ? value : 0;
      }
      get Width(): number {
          return this._width;
      }
      set Width(value: number) {
          this._width = (value > 0) ? value : 0;
      }
  }
#+end_src

#+cindex:accessor
TypeScript supports =getters/setters= as a way of intercepting
accesses to a member of an object.  This gives you a way of having
finer-grained control over how a member is accessed on each object.

#+cindex:getter
#+cindex:setter
Let’s convert a simple class to use =get= and =set=.  First, let’s
start with an example without getters and setters.

#+begin_src js
class Employee {
    fullName: string;
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    console.log(employee.fullName);
}
#+end_src

While allowing people to randomly set =fullName= directly is pretty
handy, we may also want enforce some constraints when =fullName= is
set.

In this version, we add a =setter= that checks the length of the
=newName= to make sure it’s compatible with the =max-length= of our
backing database field.  If it isn’t we throw an error notifying
client code that something went wrong.

To preserve existing functionality, we also add a simple =getter= that
retrieves =fullName= unmodified.

#+begin_src js
const fullNameMaxLength = 10;

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (newName && newName.length > fullNameMaxLength) {
            throw new Error("fullName has a max length of " + fullNameMaxLength);
        }

        this._fullName = newName;
    }
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    console.log(employee.fullName);
}
#+end_src

To prove to ourselves that our accessor is now checking the length of
values, we can attempt to assign a name longer than 10 characters and
verify that we get an error.

#+cindex:accessors
A couple of things to note about accessors:

#+cindex:ECMAScript 5
- First, accessors require you to set the compiler to output
  ECMAScript 5 or higher.  Downleveling to ECMAScript 3 is not
  supported.

  #+cindex:get
  #+cindex:set
- Second, accessors with a =get= and no =set= are automatically
  inferred to be =readonly=.  This is helpful when generating a
  ~.d.ts~ file from your code, because users of your property can see
  that they can’t change it.

** Creating Classes
   #+cindex:classes
   Creating classes in Typescript is essentially the same as creating
   interfaces.  Here is a simple =Point= class that keeps track of an ~x~
   and ~y~ position.

   #+begin_src js -n
  class Point {
      public x: number;
      public y: number;
      constructor(x: number, y = 0) {
          this.x = x;
          this.y = y;
      }
  }
   #+end_src

   This example includes a default value for the property ~y~.
   TypeScript treats parameters with default values as optional
   parameters.  This provides a simple method for ensuring you are always
   operating on instantiated objects.

   Here is the JavaScript output for the =Point= class:

   #+begin_src js -n
     var Point = (function () {
	 function Point(x, y) {
	     if (typeof y == "undefined") { y = 0; }
	     this.x = x;
	     this.y = y;
	 }
	 return Point;
     })();
   #+end_src

*** TypeScript Classes and JavaScript Closures
   #+cindex:closures
   Public methods and and static members will be added to the =Point=
   function's prototype.  Classes, modules, and enums in TypeScript all
   compile into JavaScript closures.  Closures are a JavaScript construct
   that provide a way of creating a private state for a specific segment
   of code.  When a closure is created, it contains two things:

   - a function; and
   - the state of the environment when the function was created.


   The function is returned to the caller of the closure and the state is
   used when the function is called.

*** How Interfaces and Classes Interact
Classes can optionally inherit type information from interfaces using
the ~implements~ keyword.  The class will then be required to
implement all of the interface members.  Note that decorating the
constructor's parameters with ~public~ or ~private~ keywords tells
TypeScript to treat those objects as part of the type and not just
initialization parameters.

Providing a comma-separated list of interfaces after the ~implements~
keyword allows the class to provide implementations of a variety of
different contracts.

#+begin_src js -n
  interface IPoint {
      x: number;
      y: number;
  }

  interface ICompare {
      Compare(p2: IPoint): number
  }

  class Point implements IPoint, ICompare {
      constructor(public x: number, public y = 0) {
      }
      public Compare(p2: IPoint):number {
	      // <return 0, 1, or -1>
      }
  }
#+end_src

Keeping the interfaces simple allows them to be more reusable across
applications.  The ~Compare~ method could easily have been placed on
the IPoint interface to achieve the same result.  However, any number
of types could implement the ICompare interface, which have no need
for the members ~x~ and ~y~.

** A Simple Class-Based Example
#+cindex:ECMAScript 2015
#+cindex:class-based construction
Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript
programmers will be able to build their applications using this
object-oriented class-based approach.  In TypeScript, we allow
developers to use these techniques now, and compile them down to
JavaScript that works across all major browsers and platforms, without
having to wait for the next version of JavaScript.

Let’s take a look at a simple class-based example:

#+begin_src js
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
#+end_src

We declare a new class =Greeter=.  This class has three members: a
property called =greeting=, a constructor, and a method =greet=.

#+cindex:@code{this}
You’ll notice that in the class when we refer to one of the members of
the class we prepend =this=.  This denotes that it’s a member access.

In the last line we construct an instance of the =Greeter= class using
~new~.  This calls into the constructor we defined earlier, creating a
new object with the =Greeter= shape, and running the constructor to
initialize it.

** Inheritance---Class Heritage
There are two types of class heritage in TypeScript.  A class can
implement an interface using the ~implements~ keyword and a class can
inherit from another class using the ~extends~ keyword.

#+cindex:inheritance
#+cindex:extend
#+cindex:class-based programming
In TypeScript, we can use common object-oriented patterns.  One of the
most fundamental patterns in class-based programming is being able to
extend existing classes to create new ones using inheritance.

Let’s take a look at an example:

#+begin_src js
class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}

class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
#+end_src

#+cindex:derived class
#+cindex:base class
#+cindex:@code{extends} keyword
#+cindex:subclass
#+cindex:superclass
This example shows the most basic inheritance feature: classes inherit
properties and methods from base classes.  Here, =Dog= is a derived
class that derives from the =Animal= base class using the ~extends~
keyword.  Derived classes are often called subclasses, and base classes
are often called superclasses.

Because =Dog= extends the functionality from =Animal=, we were able to
create an instance of =Dog= that could both ~bark()~ and ~move()~.

Let’s now look at a more complex example.

#+begin_src js
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);
#+end_src

This example covers a few other features we didn’t previously
mention.  Again, we see the ~extends~ keywords used to create two new
subclasses of =Animal=: =Horse= and =Snake=.

#+cindex:@code{super()}
#+cindex:constructor function
One difference from the prior example is that each derived class that
contains a constructor function must call ~super()~ which will execute
the constructor of the base class.  What’s more, before we ever access
a property on ~this~ in a constructor body, we have to call ~super()~.
This is an important rule that TypeScript will enforce.

#+cindex:override methods
The example also shows how to override methods in the base class with
methods that are specialized for the subclass.  Here both =Snake= and
=Horse= create a ~move~ method that overrides the ~move~ from
=Animal=, giving it functionality specific to each class.  Note that
even though ~tom~ is declared as an =Animal=, since its value is a
=Horse=, calling ~tom.move(34)~ will call the overriding method in
=Horse=:

#+begin_example
Slithering...
Sammy the Python moved 5m.
Galloping...
Tommy the Palomino moved 34m.
#+end_example

** Abstract Classes
#+cindex:abstract class
#+cindex:@code{abstract} keyword
Abstract classes are base classes from which other classes may be
derived.  They may not be instantiated directly.  Unlike an interface,
an abstract class may contain implementation details for its members.
The =abstract= keyword is used to define abstract classes as well as
abstract methods within an abstract class.

#+begin_src js
abstract class Animal {
    abstract makeSound(): void;
    move(): void {
        console.log("roaming the earth...");
    }
}
#+end_src

#+cindex:abstract method
#+cindex:@code{abstract} keyword
Methods within an abstract class that are marked as abstract do not
contain an implementation and must be implemented in derived classes.
Abstract methods share a similar syntax to interface methods.  Both
define the signature of a method without including a method body.
However, abstract methods must include the =abstract= keyword and may
optionally include access modifiers.

#+begin_src js -n
abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log("Department name: " + this.name);
    }

    abstract printMeeting(): void; // must be implemented in derived classes
}

class AccountingDepartment extends Department {

    constructor() {
        super("Accounting and Auditing"); // constructors in derived classes must call super()
    }

    printMeeting(): void {
        console.log("The Accounting Department meets each Monday at 10am.");
    }

    generateReports(): void {
        console.log("Generating accounting reports...");
    }
}

let department: Department; // ok to create a reference to an abstract type
department = new Department(); // error: cannot create an instance of an abstract class
department = new AccountingDepartment(); // ok to create and assign a non-abstract subclass
department.printName();
department.printMeeting();
department.generateReports(); // error: method doesn't exist on declared abstract type
#+end_src

** Advanced Techniques
*** Constructor Functions
When you declare a class in TypeScript, you are actually creating
multiple declarations at the same time.

{{{heading(Class Type)}}}

The first is the type of the instance of the class.

#+begin_src js
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter: Greeter;
greeter = new Greeter("world");
console.log(greeter.greet());
#+end_src

Here, when we say ~let greeter: Greeter~, we’re using =Greeter= as the
type of instances of the class =Greeter=.  This is almost second
nature to programmers from other object-oriented languages.

{{{heading(Constructor Function)}}}

#+cindex:constructor function, class type
We’re also creating another value that we call the /constructor
function/.  This is the function that is called when we ~new~ up
instances of the class.  To see what this looks like in practice,
let’s take a look at the JavaScript created by the above example:

#+begin_src js
let Greeter = (function () {
    function Greeter(message) {
        this.greeting = message;
    }
    Greeter.prototype.greet = function () {
        return "Hello, " + this.greeting;
    };
    return Greeter;
})();

let greeter;
greeter = new Greeter("world");
console.log(greeter.greet());
#+end_src

Here, ~let Greeter~ is going to be assigned the constructor function.
When we call ~new~ and run this function, we get an instance of the
class.  The constructor function also contains all of the static
members of the class.  Another way to think of each class is that
there is an instance side and a static side.

Let’s modify the example a bit to show this difference:

#+begin_src js
class Greeter {
    static standardGreeting = "Hello, there";
    greeting: string;
    greet() {
        if (this.greeting) {
            return "Hello, " + this.greeting;
        }
        else {
            return Greeter.standardGreeting;
        }
    }
}

let greeter1: Greeter;
greeter1 = new Greeter();
console.log(greeter1.greet());

let greeterMaker: typeof Greeter = Greeter;
greeterMaker.standardGreeting = "Hey there!";

let greeter2: Greeter = new greeterMaker();
console.log(greeter2.greet());
#+end_src

In this example, ~greeter1~ works similarly to before.  We instantiate
the =Greeter class, and use this object.  This we have seen before.

Next, we then use the class directly. Here we create a new variable
called ~greeterMaker~.  This variable will hold the class itself, or
said another way its constructor function.  Here we use ~typeof~
Greeter, that is “give me the type of the Greeter class itself” rather
than the instance type.  Or, more precisely, “give me the type of the
symbol called Greeter,” which is the type of the constructor function.
This type will contain all of the static members of Greeter along with
the constructor that creates instances of the Greeter class.  We show
this by using ~new~ on ~greeterMaker~, creating new instances of
=Greeter= and invoking them as before.
*** Using a Class as an Interface
A class declaration creates two things: a type representing instances
of the class and a constructor function.  Because classes create
types, you can use them in the same places you would be able to use
interfaces.

#+begin_src js
class Point {
    x: number;
    y: number;
}

interface Point3d extends Point {
    z: number;
}

let point3d: Point3d = {x: 1, y: 2, z: 3};
#+end_src
* Enums
** About Enums
#+cindex:enum
#+cindex:named constant
#+cindex:enum declaration
Enums are an entity intended for holding a specific value that is
referenced using a name to keep code readable.  An enum value is
simply a number or string associated with a named constant.  Here is
an enum declaration:

#+begin_src js -n
  enum ShapeType {
      Rectangle,
      Circle,
      Line,
      Freehand
  }
#+end_src

#+cindex:enum value, access
#+cindex:enum, JavaScript code
You access the enum values like you were accessing a class's static
members:  ~ShapeType.Rectangle~.  The real magic behind enums in
TypeScript is how they are generated in JavaScript:

#+begin_src js -n
  var ShapeType;
  (function (ShapeType) {
      ShapeType[ShapeType["Rectangle"] = 0] = "Rectangle";
      ShapeType[ShapeType["Circle"] = 1] = "Circle";
      ShapeType[ShapeType["Line"] = 2] = "Line";
      ShapeType[ShapeType["Freehand"] = 3] = "Freehand";
  })(ShapeType || (ShapeType = {}));
#+end_src

#+cindex:mapping, enum
TypeScript is creating a two-way mapping between the named constant
and the number it is mapped to.  This creates a number of ways in
which you can access the values of an enum.  =ShapeType= has been
created inside of an anonymous function that returns an object that
has two been given two properties for each member of the enum.  Taking
advantage of JavaScript's dynamic typing system, TypeScript adds a
property with the string value of the member name and maps it to an
integer value.  That integer value is simultaneously added as a
property of the =ShapeType= object and is mapped to the string value
of the named member.  Thus:

: ShapeType[ShapeType.Rectangle]

produces the string "Rectangle".

** Constant Members and Computed Members

{{{heading(Constant Members)}}}

#+cindex:member, constant enum
#+cindex:member, computer enum
TypeScript provides two types of enum members that can be created:
- constant members
- computed members


The above example were all constant members with auto-generated
constant values, These numbers are sequential starting from zero
unless a constant value is provided to a member.  Then, all of the
subsequent members of the =enum= will be in sequence with the number
given.

{{{heading(Computed Members)}}}

#+cindex:computed member, enum
Computed members are still named constants but the integer value they
are mapped to is provided by an expression.  This can be either an
in-line or a function call to another segment of code.  The only
stipulation on the expression that you provide is that it returns a
number.  In the following example, the =ShapeType= enum generates some
specific indexes as well as creating a computed member:

#+begin_src js -n
  function GetEnumValue(): number {
      return Date.now();
  }

  enum ShapeType {
      Rectangle = 3,
      Circle,
      Line,
      Freehand,
      Random = GenEnumValue();
  }

#+end_src

Here is the generated JavaScript code:

#+begin_src js -n
  function GetEnumValue() {
      return Date.now();
  }

  var Shapetype;
  (function (ShapeType) {
      ShapeType[ShapeType["Rectangle"] = 3] = "Rectangle";
      ShapeType[ShapeType["Circle"] = 4] = "Circle";
      ShapeType[ShapeType["Line"] = 5] = "Line";
      ShapeType[ShapeType["Freehand"] = 6] = "Freehand";
      ShapeType[ShapeType["Randam"] = GetEnumValue()] = "Random";
  })(ShapeType || (ShapeType = {}));
#+end_src

The expression provided to the computed member is built directly into
the enum declaration generated.  The expression will be evaluated at
runtime but only when =ShapeType= is initialized.  Once the expression
has been run, the result will remain a member of the =ShapeType=
object.

** Enums can be Merged
Enum definitions can be merged.  If two enum declarations are placed
in different segments of code with the same type name, they will
contribute to the same object.  You can see this in the last line of
the enum declaration in the resulting JavaScript.  If the object
exists, then each new property is added to the existing object;
otherwise a new object is created and the properties are applied.

** Enum Details
#+cindex:enum type
Enums allow us to define a set of named constants.  Using enums can
make it easier to document intent, or create a set of distinct cases.
TypeScript provides both numeric and string-based enums.

{{{heading(Numeric Enums)}}}

#+cindex:@code{enum} keyword
#+cindex:numeric enum
We’ll first start off with numeric enums, which are probably more
familiar if you’re coming from other languages.  An enum can be
defined using the =enum= keyword.

#+begin_src js
enum Direction {
    Up = 1,
    Down,
    Left,
    Right,
}
#+end_src

#+cindex:enum initializer
Above, we have a numeric enum where =Up= is initialized with 1.  All
of the following members are auto-incremented from that point on.  In
other words, =Direction.Up= has the value 1, =Down= has 2, =Left= has
3, and =Right= has 4.

If we wanted, we could leave off the initializers entirely:

#+begin_src js
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
#+end_src

#+cindex:auto-incrementing initializer
Here, =Up= would have the value 0, =Down= would have 1, etc.  This
auto-incrementing behavior is useful for cases where we might not care
about the member values themselves, but do care that each value is
distinct from other values in the same enum.

Using an enum is simple: just access any member as a property off of
the enum itself, and declare types using the name of the enum:

#+begin_src js
enum Response {
    No = 0,
    Yes = 1,
}

function respond(recipient: string, message: Response): void {
    // ...
}

respond("Princess Caroline", Response.Yes)
#+end_src

Numeric enums can be mixed in computed and constant members (see
below).  The short story is, enums without initializers either need to
be first, or have to come after numeric enums initialized with numeric
constants or other constant enum members.  In other words, the
following isn’t allowed:

#+begin_src js
enum E {
    A = getSomeValue(),
    B, // Error! Enum member must have initializer.
}
#+end_src

{{{heading(String Enums)}}}

#+cindex:string enum
#+cindex:constant-initialized
String enums are a similar concept, but have some subtle runtime
differences as documented below.  In a string enum, each member has to
be constant-initialized with a string literal, or with another string
enum member.

#+begin_src js
enum Direction {
    Up = "UP",
    Down = "DOWN",
    Left = "LEFT",
    Right = "RIGHT",
}
#+end_src

#+cindex:serialize, string enum
While string enums don’t have auto-incrementing behavior, string enums
have the benefit that they “serialize” well.  In other words, if you
were debugging and had to read the runtime value of a numeric enum,
the value is often opaque---it doesn’t convey any useful meaning on
its own (though reverse mapping can often help), string enums allow
you to give a meaningful and readable value when your code runs,
independent of the name of the enum member itself.

{{{heading(Heterogenous Enums)}}}

Technically enums can be mixed with string and numeric members, but
it’s not clear why you would ever want to do so:

#+begin_src js
enum BooleanLikeHeterogeneousEnum {
    No = 0,
    Yes = "YES",
}
#+end_src

Unless you’re really trying to take advantage of JavaScript’s runtime
behavior in a clever way, it’s advised that you don’t do this.

{{{heading(Computed and Constant Members)}}}

#+cindex:constant enum
#+cindex:computed enum
Each enum member has a value associated with it which can be either
constant or computed.  An enum member is considered constant if:

- It is the first member in the enum and it has no initializer, in
  which case it’s assigned the value 0:

  #+begin_src js
  // E.X is constant:
  enum E { X }
  #+end_src

- It does not have an initializer and the preceding enum member was a
  numeric constant.  In this case the value of the current enum member
  will be the value of the preceding enum member plus one.

  #+begin_src js
  // All enum members in 'E1' and 'E2' are constant.

  enum E1 { X, Y, Z }

  enum E2 {
      A = 1, B, C
  }
  #+end_src

- The enum member is initialized with a constant enum expression.  A
  constant enum expression is a subset of TypeScript expressions that
  can be fully evaluated at compile time.  An expression is a constant
  enum expression if it is:

  1. a literal enum expression (basically a string literal or a
     numeric literal)

  2. a reference to previously defined constant enum member (which can
     originate from a different enum)

  3. a parenthesized constant enum expression

  4. one of the +, -, ~ unary operators applied to constant enum
     expression

  5. +, -, *, /, %, <<, >>, >>>, &, |, ^ binary operators with
     constant enum expressions as operands

  It is a compile time error for constant enum expressions to be
  evaluated to =NaN= or =Infinity=.


#+cindex:computed enum
In all other cases enum member is considered computed.

#+begin_src js
enum FileAccess {
    // constant members
    None,
    Read    = 1 << 1,
    Write   = 1 << 2,
    ReadWrite  = Read | Write,
    // computed member
    G = "123".length
}
#+end_src

{{{heading(Using Enums and Enum Member Types)}}}

#+cindex:literal enum
There is a special subset of constant enum members that aren’t
calculated: literal enum members.  A literal enum member is a constant
enum member with no initialized value, or with values that are
initialized to:

- any string literal (e.g. "foo", "bar, "baz")

- any numeric literal (e.g. 1, 100)

- a unary minus applied to any numeric literal (e.g. -1, -100)


When all members in an enum have literal enum values, some special
semantics come to play.

The first is that enum members also become types as well!  For
example, we can say that certain members can only have the value of an
enum member:

#+begin_src js
enum ShapeKind {
    Circle,
    Square,
}

interface Circle {
    kind: ShapeKind.Circle;
    radius: number;
}

interface Square {
    kind: ShapeKind.Square;
    sideLength: number;
}

let c: Circle = {
    kind: ShapeKind.Square, // Error! Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.
    radius: 100,
}
#+end_src

#+cindex:union type
The other change is that enum types themselves effectively become a
union of each enum member.  While we haven’t discussed union types
yet, all that you need to know is that with union enums, the type
system is able to leverage the fact that it knows the exact set of
values that exist in the enum itself.  Because of that, TypeScript can
catch silly bugs where we might be comparing values incorrectly.  For
example:

#+begin_src js
enum E {
    Foo,
    Bar,
}

function f(x: E) {
    if (x !== E.Foo || x !== E.Bar) {
        //             ~~~~~~~~~~~
        // Error! This condition will always return 'true' since the types 'E.Foo' and 'E.Bar' have no overlap.
    }
}
#+end_src

In that example, we first checked whether ~x~ was not ~E.Foo~.  If
that check succeeds, then our =||= will short-circuit, and the body of
the ‘if’ will run.  However, if the check didn’t succeed, then ~x~ can
only be ~E.Foo~, so it doesn’t make sense to see whether it’s equal to
~E.Bar~.

{{{heading(Enums at Runtime)}}}

Enums are real objects that exist at runtime.  For example, the
following enum

#+begin_src js
enum E {
    X, Y, Z
}
#+end_src

{{{noindent}}}an actually be passed around to functions.

#+begin_src js
function f(obj: { X: number }) {
    return obj.X;
}

// Works, since 'E' has a property named 'X' which is a number.
f(E);
#+end_src

{{{heading(Enums at Compile Time)}}}

#+cindex:@code{keyof} keyword
#+cindex:@code{keyof typeof}
Even though Enums are real objects that exist at runtime, the ~keyof~
keyword works differently than you might expect for typical objects.
Instead, use ~keyof typeof~ to get a Type that represents all Enum
keys as strings.

#+begin_src js
enum LogLevel {
    ERROR, WARN, INFO, DEBUG
}

/**
 * This is equivalent to:
 * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
 */
type LogLevelStrings = keyof typeof LogLevel;

function printImportant(key: LogLevelStrings, message: string) {
    const num = LogLevel[key];
    if (num <= LogLevel.WARN) {
       console.log('Log level key is: ', key);
       console.log('Log level value is: ', num);
       console.log('Log level message is: ', message);
    }
}
printImportant('ERROR', 'This is a message');
#+end_src

{{{heading(Reverse Mappings)}}}

#+cindex:reverse mapping
In addition to creating an object with property names for members,
numeric enums members also get a reverse mapping from enum values to
enum names.  For example, in this example:

#+begin_src js
enum Enum {
    A
}
let a = Enum.A;
let nameOfA = Enum[a]; // "A"
#+end_src

TypeScript might compile this down to something like the the following
JavaScript:

#+begin_src js
var Enum;
(function (Enum) {
    Enum[Enum["A"] = 0] = "A";
})(Enum || (Enum = {}));
var a = Enum.A;
var nameOfA = Enum[a]; // "A"
#+end_src

In this generated code, an enum is compiled into an object that stores
both forward (name -> value) and reverse (value -> name) mappings.
References to other enum members are always emitted as property
accesses and never inlined.

Keep in mind that string enum members do not get a reverse mapping
generated at all.

{{{heading(Const Enums)}}}

In most cases, enums are a perfectly valid solution.  However
sometimes requirements are tighter.  To avoid paying the cost of extra
generated code and additional indirection when accessing enum values,
it’s possible to use =const= enums.  Const enums are defined using the
=const= modifier on our enums:

#+begin_src js
const enum Enum {
    A = 1,
    B = A * 2
}
#+end_src

Const enums can only use constant enum expressions and unlike regular
enums they are completely removed during compilation.  Const enum
members are inlined at use sites.  This is possible since =const=
enums cannot have computed members.

#+begin_src js
const enum Directions {
    Up,
    Down,
    Left,
    Right
}

let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]
#+end_src

{{{noindent}}}in generated code will become:

#+begin_src js
var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];
#+end_src

{{{heading(Ambient Enums)}}}

#+cindex:ambient enum
Ambient enums are used to describe the shape of already existing enum
types.

#+begin_src js
declare enum Enum {
    A = 1,
    B,
    C = 2
}
#+end_src

One important difference between ambient and non-ambient enums is
that, in regular enums, members that don’t have an initializer will be
considered constant if its preceding enum member is considered
constant. In contrast, an ambient (and non-const) enum member that
does not have initializer is always considered computed.
* Variables
** Var
*** Var Scoping Rules
{{{heading(Function Scope)}}}

#+cindex:function scope
#+cindex:@code{var} declaration
=var= declarations are accessible anywhere within their containing
function, module, namespace, or global scope regardless of the
containing block.  Parameters are also function scoped.

{{{subheading(Problems with Function Scope)}}}

One problem they exacerbate is the fact that it is not an error to
declare the same variable multiple times.  Variables can be
accidentally overwritten this way.

This also occurs within for-loops:

#+begin_src js
for (var i = 0; i < 10; i++) {
    setTimeout(function() { console.log(i); }, 100 * i);
}
#+end_src

{{{noindent}}}which produces the following output:

#+begin_example
10
10
10
10
10
10
10
10
10
10
#+end_example

~setTimeout~ will run a function after some number of milliseconds,
but only after the for loop has stopped executing; by the time the for
loop has stopped executing, the value of ~i~ is 10.  So each time the
given function gets called, it will print out 10!

#+cindex:IIFE
#+cindex:immediately invoked function expression
A common work around is to use an IIFE - an Immediately Invoked
Function Expression - to capture ~i~ at each iteration:

#+begin_src js
for (var i = 0; i < 10; i++) {
    // capture the current state of 'i'
    // by invoking a function with its current value
    (function(i) {
        setTimeout(function() { console.log(i); }, 100 * i);
    })(i);
}
#+end_src

The ~i~ in the parameter list actually shadows the ~i~ declared in the
for loop, and which is used to invoke the function.  The function
closes over the value of the parameter ~i~ when it is invoked, and
will be available to the ~setTimeout~ function when it runs much
later.

** Let
#+cindex:lexical scope
#+cindex:block scope
#+cindex:local variable
The =let= statement declares a block scope local variable, optionally
initializing it to a value.  The other difference between =var= and
=let= is that the latter is initialized to value only when parser
evaluates it.  The =let= does not create properties of the window
object when declared globally.  The main difference between =var= and
=let= is that the scope of a =var= variable is the entire enclosing
function.

#+begin_src js
var x = 'global';
let y = 'global';
console.log(this.x); // "global"
console.log(this.y); // undefined
#+end_src

When a variable is declared using ~let~, it uses what some call
lexical-scoping or block-scoping.  Unlike variables declared with
~var~, whose scopes leak out to their containing function,
block-scoped variables are not visible outside of their nearest
containing block or =for-loop=.

#+cindex:temporal dead zone
Another property of block-scoped variables is that they can’t be read
or written to before they’re actually declared.  While these variables
are “present” throughout their scope, all points up until their
declaration are part of their temporal dead zone.  This is just a
sophisticated way of saying you can’t access them before the ~let~
statement, and luckily TypeScript will let you know that.

You can still capture a block-scoped variable before it’s declared.
The only catch is that it’s illegal to call that function before the
declaration.  If targeting ES2015, a modern runtime will throw an
error; however, right now TypeScript is permissive and won’t report
this as an error.

#+begin_src js
function foo() {
    // okay to capture 'a'
    return a;
}

// illegal call 'foo' before 'a' is declared
// runtimes should throw an error here
foo();

let a;
#+end_src

*** Emulate Private Members
#+cindex:private member
In dealing with constructors it is possible to use the ~let~ bindings
to share one or more private members without using closures:

#+caption:Emulate private members using let
#+name:emulate-private-members-using-let
#+begin_src js -n
var Thing;

{ // BLOCK SCOPE
  let privateScope = new WeakMap(); // PRIVATE MEMBERS
  let counter = 0;

  Thing = function() {
    this.someProperty = 'foo';

    privateScope.set(this, {
      hidden: ++counter,
    });
  };

  Thing.prototype.showPublic = function() {
    return this.someProperty;
  };

  Thing.prototype.showPrivate = function() {
    return privateScope.get(this).hidden;
  };
}

console.log(typeof privateScope); // "undefined"

var thing = new Thing();

console.log(thing); // Thing {someProperty: "foo"}

thing.showPublic(); // "foo"

thing.showPrivate(); // 1
#+end_src

The same privacy pattern with closures over local variables can be
created with ~var~, but those need a function scope (typically an IIFE
in the module pattern) instead of just a block scope like in the
example above.

*** Temporal Dead Zone
Unlike variables declared with ~var~, which will start with the value
undefined, ~let~ variables are not initialized until their definition
is evaluated.  Accessing the variable before the initialization
results in a =ReferenceError=.  The variable is in a "temporal dead
zone" from the start of the block until the initialization is
processed.

Unlike with simply undeclared variables and variables that hold a
value of =undefined=, using the ~typeof~ operator to check for the
type of a variable in that variable's TDZ will throw a
=ReferenceError=:

** Const
~const~ declarations are another way of declaring variables.  They are
like ~let~ declarations but, as their name implies, their value cannot
be changed once they are bound.  In other words, they have the same
scoping rules as ~let~, but you can’t re-assign to them.  This should
not be confused with the idea that the values they refer to are
immutable.  Unless you take specific measures to avoid it, the
internal state of a ~const~ variable is still modifiable.
Fortunately, TypeScript allows you to specify that members of an
object are =readonly=

{{{heading(Principle of Least Privilege)}}}

#+cindex:least privilege
Applying the principle of /least privilege/, all declarations other
than those you plan to modify should use ~const~.  The rationale is
that if a variable didn’t need to get written to, others working on
the same codebase shouldn’t automatically be able to write to the
object, and will need to consider whether they really need to reassign
to the variable.  Using ~const~ also makes code more predictable when
reasoning about flow of data.
** Destructuring
*** Array Destructuring
#+cindex:destructuring
#+cindex:array destructuring
The simplest form of destructuring is array destructuring assignment:

#+begin_src js
let input = [1, 2];
let [first, second] = input; // first := 1, second := 2
#+end_src

This creates two new variables named first and second.  This is
equivalent to using indexing, but is much more convenient:

#+begin_src js
first = input[0];
second = input[1];
#+end_src

Destructuring works with already-declared variables as well:

#+begin_src js
// swap variables
[first, second] = [second, first];
#+end_src

And with parameters to a function:

#+begin_src js
function f([first, second]: [number, number]) {
    console.log(first);
    console.log(second);
}
f([1, 2]);
#+end_src

You can create a variable for the remaining items in a list using the
syntax ...:

#+begin_src js
let [first, ...rest] = [1, 2, 3, 4];
console.log(first); // outputs 1
console.log(rest); // outputs [ 2, 3, 4 ]
#+end_src

Of course, since this is JavaScript, you can just ignore trailing
elements you don’t care about:

#+begin_src js
let [first] = [1, 2, 3, 4];
console.log(first); // outputs 1
#+end_src

Or other elements:

#+begin_src js
let [, second, , fourth] = [1, 2, 3, 4];
console.log(second); // outputs 2
console.log(fourth); // outputs 4
#+end_src

*** Tuple Destructuring
#+cindex:destructuring
#+cindex:tuple destructuring
Tuples may be destructured like arrays; the destructuring variables
get the types of the corresponding tuple elements:

#+begin_src js
let tuple: [number, string, boolean] = [7, "hello", true];

let [a, b, c] = tuple; // a: number, b: string, c: boolean
#+end_src

It’s an error to destructure a tuple beyond the range of its elements.
As with arrays, you can destructure the rest of the tuple with ..., to
get a shorter tuple; and ignore trailing elements, or other elements.

*** Object Destructuring
#+cindex:destructuing
#+cindex:object destructuring
You can also destructure objects:

#+begin_src js
let o = {
    a: "foo",
    b: 12,
    c: "bar"
};
Let { a, b } = o;
#+end_src

This creates new variables ~a~ and ~b~ from ~o.a~ and ~o.b~.  Notice
that you can skip ~c~ if you don’t need it.

Like array destructuring, you can have assignment without declaration:

#+begin_src js
({ a, b } = { a: "baz", b: 101 });
#+end_src

Notice that we had to surround this statement with
parentheses. JavaScript normally parses a ={= as the start of block.

You can create a variable for the remaining items in an object using
the syntax ...:

#+begin_src js
let { a, ...passthrough } = o;
let total = passthrough.b + passthrough.c.length;
#+end_src

{{{heading(Property Renaming)}}}

#+pindex:property renaming
You can also give different names to properties:

#+begin_src js
let { a: newName1, b: newName2 } = o;
#+end_src

You can read ~a: newName1~ as “a as newName1”.  The direction is
left-to-right, as if you had written:

#+begin_src js
let newName1 = o.a;
let newName2 = o.b;
#+end_src

Confusingly, the colon here does not indicate the type.  The type, if
you specify it, still needs to be written after the entire
destructuring:

#+begin_src js
let { a, b }: { a: string, b: number } = o;
#+end_src

{{{heading(Default Values)}}}

#+cindex:default values
Default values let you specify a default value in case a property is
=undefined=:

#+begin_src js
function keepWholeObject(wholeObject: { a: string, b?: number }) {
    let { a, b = 1001 } = wholeObject;
}
#+end_src

In this example the ~b?~ indicates that ~b~ is optional, so it may be
=undefined=.  ~keepWholeObject~ now has a variable for ~wholeObject as
well as the properties ~a~ and ~b~, even if ~b~ is =undefined=.

*** Function Declarations and Destructuring
#+cindex:destructuring
#+cindex:function declarations and destructuring
Destructuring also works in function declarations. For simple cases
this is straightforward:

#+begin_src js
type C = { a: string, b?: number }
function f({ a, b }: C): void {
    // ...
}
#+end_src

But specifying defaults is more common for parameters, and getting
defaults right with destructuring can be tricky.  First of all, you
need to remember to put the pattern before the default value.

#+begin_src js
function f({ a="", b=0 } = {}): void {
    // ...
}
f();
#+end_src

Then, you need to remember to give a default for optional properties
on the destructured property instead of the main initializer.  Remember
that ~C~ was defined with ~b~ optional:

#+begin_src js
function f({ a, b=0 } = { a: "" }): void {
    // ...
}
f({ a: "yes" }); // ok, default b = 0
f(); // ok, default to { a: "" }, which then defaults b = 0
f({}); // error, 'a' is required if you supply an argument
#+end_src

Use destructuring with care.  As the previous example demonstrates,
anything but the simplest destructuring expression is confusing.  This
is especially true with deeply nested destructuring, which gets really
hard to understand even without piling on renaming, default values,
and type annotations.  Try to keep destructuring expressions small and
simple.  You can always write the assignments that destructuring would
generate yourself.
** Spreading
#+cindex:@code{spread} operator
#+cindex:spreading
The =spread= operator is the opposite of destructuring.  It allows you
to spread an array into another array, or an object into another
object.  For example:

#+begin_src js
let first = [1, 2];
let second = [3, 4];
let bothPlus = [0, ...first, ...second, 5];
#+end_src

#+cindex:shallow copy, @code{spread} operator
This gives ~bothPlus~ the value =[0, 1, 2, 3, 4, 5]=.  Spreading
creates a shallow copy of first and second.  They are not changed by
the spread.

You can also spread objects:

#+begin_src js
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { ...defaults, food: "rich" };
#+end_src

Now search is ={ food: "rich", price: "$$", ambiance: "noisy" }=.
Object spreading is more complex than array spreading.  Like array
spreading, it proceeds from left-to-right, but the result is still an
object.  This means that properties that come later in the spread
object overwrite properties that come earlier.  So if we modify the
previous example to spread at the end:

#+begin_src js
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { food: "rich", ...defaults };
#+end_src

Then the =food= property in defaults overwrites =food: "rich"=, which
is not what we want in this case.

Object spread also has a couple of other surprising limits.  First, it
only includes an objects’ own, enumerable properties.  Basically, that
means you lose methods when you spread instances of an object:

#+begin_src js
class C {
  p = 12;
  m() {
  }
}
let c = new C();
let clone = { ...c };
clone.p; // ok
clone.m(); // error!
#+end_src

Second, the Typescript compiler doesn’t allow spreads of type
parameters from generic functions.  That feature is expected in future
versions of the language.
* Generics
** Type Parameters
#+cindex:type parameters
Generics define the third category of objects in TypeScript: type
parameters.  Type parameters are defined inside of =<...>=.  They can
be used on interfaces or class definitions to create functionality for
a broad set of object types that may or may not be known at the time
of development.

{{{heading(Generic Task Processor)}}}

Let’s create a generic task processor.  Assume the simplest possible
implementation, a sequential process that passes a list of generic
tasks to a function to have them run.

#+begin_src js -n
  interface ITask {
      Id: number;
      Execute(): boolean;
      Error: string;
  }

  function ProcessTask<T extends ITasks>(tasks: T[]): T {
      for (var i = 0; i < tasks.length; i++) {
          if (tasks[i].Execute() == false) {
              return tasks[i];
          }
      }
      return null;
  }
#+end_src

An interface has been defined that the task processor will rely on to
execute a set of tasks sequentially.  The function declaration for
~ProcessTasks()~ contains a type parameter, =T=, which must adhere to
the =ITask= interface.  This type parameter is used as a constraint
for the objects that can be passed in as part of the tasks array, and
will be the return type of the function.  The tasks array is looped
through one by one and the ~Execute()~ method is called.  If this
method returns a =false= value, then the processing stops and the task
is returned.

Generics are built completely on the type annotations, so they have no
effect on the generated JavaScript.  However, if the type constraints
are not met, a compile error will be generated.

Interfaces and classes are capable of creating even more complex
structures built around a very loose type definition.  A type
parameter provided to an interface or class can be used to provide
type information for any member or function inside of the declaration
body.

{{{heading(A More Complex Task Processor)}}}

The next example moves the ~ProcessTasks()~ function inside a class
that will operate as the processor.  A generic interface is created
that will allow the creation of any number of task processors with
different implementations of the ~ProcessTask()~ function.  A class
declaration then provides its own set of type parameters and
implements the =ITaskProcessor= interface.

#+begin_src js -n
  interface ITask {
      Id: number;
      Execute(): boolean;
      Error: string;
  }

  interface ITaskProcessor<T extends ITask> {
      ProcessTasks(tasks: Array<T>): T;
      CurrentTask: T;
  }

  class TaskProcessor<T extends ITask> implements ITaskProcessor<T> {
      public CurrentTask: T = null;
      constructor() {}
      public ProcessTasks(tasks: T[]): T {
          for (var i = 0; i < tasks.length; i++) {
              this.CurrentTask = tasks[i];
              if (this.CurrentTask.Execute() == false) {
                  return tasks[i];
              }
          }
          this.CurrentTask = null;
          return null;
      }
  }
#+end_src

{{{heading(Lists of Type Parameters)}}}

Generic functions and types are not limited to a single unknown type.
Type parameters can be lists of type information that can be used
anywhere within the declaration block that the list is associated
with.  Creating a list of type parameters is the same as passing a
single type parameter, only each type is separated by a comma.
Furthermore, each generic type created in a parameter list can be used
as a base type for other type parameters inside of the type’s
definition:

#+begin_src js -n
  interface IExample<T, U extends HTMLElement> {
      Operate<V extends U>(): T;
  }
#+end_src

** Simple Generics---The Identity Function
#+cindex:identity function
The identity function is a function that will return back whatever is
passed in. You can think of this in a similar way to the echo command.
Without generics, we would either have to give the identity function a
specific type, or we could describe the identity function using the
any type:

#+BEGIN_SRC js -n
  function identity(arg: number): number {
      return arg;
  }

  function identity(arg: any): any {
      return arg;
  }
#+END_SRC

While using =any= is certainly generic in that it will cause the
function to accept any and all types for the type of ~arg~, we
actually are losing the information about what that type was when the
function returns.  If we passed in a number, the only information we
have is that any type could be returned.

{{{heading(Creating a Generic Function)}}}

#+cindex:type variable
Instead, we need a way of capturing the type of the argument in such a
way that we can also use it to denote what is being returned.  Here,
we will use a /type variable/, a special kind of variable that works
on types rather than values.

#+BEGIN_SRC js -n
function identity<T>(arg: T): T {
    return arg;
}
#+END_SRC

We’ve now added a /type variable/ =T= to the identity function.  This
=T= allows us to capture the type the user provides (e.g. =number=),
so that we can use that information later.  Here, we use =T= again as
the return type.  On inspection, we can now see the same type is used
for the argument and the return type.  This allows us to traffic that
type information in one side of the function and out the other.

#+cindex:generic function
We say that this version of the identity function is generic, as it
works over a range of types.  Unlike using =any=, it’s also just as
precise (ie, it doesn’t lose any information) as the first identity
function that used numbers for the argument and return type.

{{{heading(Calling a Generic Function)}}}

{{{subheading(Passing the Type Argument)}}}

Once we’ve written the generic identity function, we can call it in
one of two ways.  The first way is to pass all of the arguments,
including the type argument, to the function:

: let output = identity<string>("myString");  // type of output will be 'string'

Here we explicitly set =T= to be string as one of the arguments to the
function call, denoted using the =< >= around the arguments rather
than =( )=.

{{{subheading(Inferring the Type Argument)}}}

The second way is to use /type argument inference/---we let the
compiler set the value of =T= automatically based upon the type of the
argument passed to the function:

: let output = identity("myString");  // type of output will be 'string'

No explicit type was passed in angle brackets; the compiler was able
to infer the type by looking at the value of the argument, and it set
type =T= to =string=.

You may need to explicitly pass in the type arguments as we did in the
previous example when the compiler fails to infer the type, as may
happen in more complex examples.

** Working with Generic Type Arguments
When working with generics, the compiler will enforce your use of
generically typed parameters in the body of the function correctly.
For example, in the following example, the compiler will complain
about ~arg~ having a =length= member because nowhere have we said that
~arg~ has such a member.  Since a type variable can stand for any and
all types, someone using the function could have passed in a =number=
instead of something with a =length= member.

#+begin_src js -n
  function loggingIdentity<T>(arg: T): T {
      console.log(arg.length);  // Error: T doesn't have .length
      return arg;
  }
#+end_src

Let’s say that we’ve actually intended this function to work on arrays
of =T= rather than =T= directly.  Since we’re working with arrays, the
=.length= member should be available.  We can describe this just like
we would create arrays of other types:

#+begin_src js -n
  function loggingIdentity<T>(arg: T[]): T[] {
      console.log(arg.length);  // Array has a .length, so no more error
      return arg;
  }
#+end_src

You can read the type of ~loggingIdentity~ as:

#+begin_quote
the generic function ~loggingIdentity~ takes a type parameter =T=, and
an argument ~arg~ which is an array of =T= s, and returns an array of
=T= s.
#+end_quote

If we passed in an array of numbers, we’d get an array of numbers back
out, as =T= would bind to number.  This allows us to use our generic
type variable =T= as part of the types we’re working with, rather than
the whole type, giving us greater flexibility.

We can alternatively write the sample example this way:

#+begin_src js -n
  function loggingIdentity<T>(arg: Array<T>): Array<T> {
      console.log(arg.length);  // Array has a .length, so no more error
      return arg;
  }
#+end_src

** Generic Types---Generic Interfaces
The type of generic functions is just like those of non-generic
functions, with the type parameters listed first, similarly to
function declarations:

#+begin_src js -n
  function identity<T>(arg: T): T {
      return arg;
  }

  let myIdentity: <T>(arg: T) => T = identity;
#+end_src

We can also write the generic type as a *call signature of an object
literal type*:

#+begin_src js -n
  function identity<T>(arg: T): T {
      return arg;
  }

  let myIdentity: {<T>(arg: T): T} = identity;
#+end_src

{{{heading(Generic Interfaces)}}}

#+cindex:generic interface
Let’s take the object literal from the previous example and move it to
an interface:

#+begin_src js -n
  interface GenericIdentityFn {
      <T>(arg: T): T;
  }

  function identity<T>(arg: T): T {
      return arg;
  }

  let myIdentity: GenericIdentityFn = identity;
#+end_src

In a similar example, we may want to move the generic parameter to be
a parameter of the whole interface.  This lets us see what type(s)
we’re generic over (e.g. =Dictionary<string>= rather than just
=Dictionary=).  This makes the type parameter visible to all the other
members of the interface.

#+begin_src js -n
  interface GenericIdentityFn<T> {
      (arg: T): T;
  }

  function identity<T>(arg: T): T {
      return arg;
  }

  let myIdentity: GenericIdentityFn<number> = identity;
#+end_src

#+cindex:generic type
Notice that our example has changed to be something slightly
different.  Instead of describing a generic function, we now have a
non-generic function signature that is a part of a *generic type*.
When we use ~GenericIdentityFn~, we now will also need to specify the
corresponding type argument (here: =number=), effectively locking in
what the underlying call signature will use.

** Generic Classes
#+cindex:generic class
A generic class has a similar shape to a generic interface. Generic
classes have a generic type parameter list in angle brackets (=< >=)
following the name of the class.

#+begin_src js -n
  class GenericNumber<T> {
      zeroValue: T;
      add: (x: T, y: T) => T;
  }

  let myGenericNumber = new GenericNumber<number>();
  myGenericNumber.zeroValue = 0;
  myGenericNumber.add = function(x, y) { return x + y; };
#+end_src

Nothing is restricting it to only use the =number= type.  We could
have instead used =string= or even more complex objects.

#+begin_src js -n
  let stringNumeric = new GenericNumber<string>();
  stringNumeric.zeroValue = "";
  stringNumeric.add = function(x, y) { return x + y; };

  console.log(stringNumeric.add(stringNumeric.zeroValue, "test"));
#+end_src

Just as with interface, putting the type parameter on the class itself
lets us make sure all of the properties of the class are working with
the same type.

Generic classes are only generic over their instance side rather than
their static side, so when working with classes, static members can
not use the class’s type parameter.

** Generic Constraints
#+cindex:constraint, generic
#+cindex:generic constraint
Instead of working with any and all types, we’d like to /constrain/
this function to work with any and all types that also have the
=.length= property.  As long as the type has this member, we’ll allow
it, but it’s required to have at least this member.  To do so, we must
list our requirement as a /constraint/ on what =T= can be.

#+cindex:@code{extends} keyword, generics
To do so, we’ll create an interface that describes our constraint.
Here, we’ll create an interface that has a single =.length= property
and then we’ll use this interface and the ~extends~ keyword to denote
our constraint:

#+begin_src js -n
  interface Lengthwise {
      length: number;
  }

  function loggingIdentity<T extends Lengthwise>(arg: T): T {
      console.log(arg.length);  // Now we know it has a .length property, so no more error
      return arg;
  }
#+end_src

Because the generic function is now constrained, it will no longer
work over any and all types:

: loggingIdentity(3);  // Error, number doesn't have a .length property

Instead, we need to pass in values whose type has all the required
properties:

: loggingIdentity({length: 10, value: 3});

{{{heading(Using Type Parameters in Generic Constraints)}}}

You can declare a type parameter that is constrained by another type
parameter.  For example, here we’d like to get a property from an
object given its name.  We’d like to ensure that we’re not
accidentally grabbing a property that does not exist on the obj, so
we’ll place a constraint between the two types:

#+begin_src js -n
  function getProperty<T, K extends keyof T>(obj: T, key: K) {
      return obj[key];
  }

  let x = { a: 1, b: 2, c: 3, d: 4 };

  getProperty(x, "a"); // okay
  getProperty(x, "m"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.
#+end_src

{{{heading(Using Class Types in Generics)}}}

When creating factories in TypeScript using generics, it is necessary
to refer to class types by their constructor functions.  For example,

#+begin_src js -n
  function create<T>(c: {new(): T; }): T {
      return new c();
  }
#+end_src

#+cindex:generics, prototype property
#+cindex:prototype property, generics
A more advanced example uses the /prototype property/ to infer and
constrain relationships between the constructor function and the
instance side of class types.

#+begin_src js -n
  class BeeKeeper {
      hasMask: boolean;
  }

  class ZooKeeper {
      nametag: string;
  }

  class Animal {
      numLegs: number;
  }

  class Bee extends Animal {
      keeper: BeeKeeper;
  }

  class Lion extends Animal {
      keeper: ZooKeeper;
  }

  function createInstance<A extends Animal>(c: new () => A): A {
      return new c();
  }

  createInstance(Lion).keeper.nametag;  // typechecks!
  createInstance(Bee).keeper.hasMask;   // typechecks!
#+end_src
* Type Inference
#+cindex:type inference
In this section, we will cover type inference in TypeScript.  Namely,
we’ll discuss where and how types are inferred.

** Basics
In TypeScript, there are several places where type inference is used
to provide type information when there is no explicit type annotation.
For example, in this code:

#+begin_src js
let x = 3;
#+end_src

The type of the ~x~ variable is inferred to be =number=.  This kind of
inference takes place when initializing variables and members, setting
parameter default values, and determining function return types.

In most cases, type inference is straightforward.  In the following
sections, we’ll explore some of the nuances in how types are inferred.

** Best Common Type
#+cindex:best common type
When a type inference is made from several expressions, the types of
those expressions are used to calculate a “best common type”.  For
example,

#+begin_src js
let x = [0, 1, null];
#+end_src

To infer the type of ~x~ in the example above, we must consider the
type of each array element.  Here we are given two choices for the
type of the array: =number= and =null=.  The best common type
algorithm considers each candidate type, and picks the type that is
compatible with all the other candidates.

Because the best common type has to be chosen from the provided
candidate types, there are some cases where types share a common
structure, but no one type is the super type of all candidate
types.  For example:

#+begin_src js
let zoo = [new Rhino(), new Elephant(), new Snake()];
#+end_src

Ideally, we may want ~zoo~ to be inferred as an =Animal[]=, but
because there is no object that is strictly of type =Animal= in the
array, we make no inference about the array element type.  To correct
this, instead explicitly provide the type when no one type is a super
type of all other candidates:

#+begin_src js
let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
#+end_src

#+cindex:union type
When no best common type is found, the resulting inference is the
union array type, =(Rhino | Elephant | Snake)[]=.

** Contextual Typing
#+cindex:contextual typing
Type inference also works in “the other direction” in some cases in
TypeScript.  This is known as “contextual typing”.  Contextual typing
occurs when the type of an expression is implied by its location.  For
example:

#+begin_src js
window.onmousedown = function(mouseEvent) {
    console.log(mouseEvent.button);   //<- OK
    console.log(mouseEvent.kangaroo); //<- Error!
};
#+end_src

Here, the Typescript type checker used the type of the
~Window.onmousedown~ function to infer the type of the function
expression on the right hand side of the assignment.  When it did so,
it was able to infer the type of the =mouseEvent= parameter, which
does contain a =button= property, but not a =kangaroo= property.

Typescript is smart enough to infer the type of things in other
contexts as well:

#+begin_src js
window.onscroll = function(uiEvent) {
    console.log(uiEvent.button); //<- Error!
}
#+end_src

#+cindex:contextually typed position
If this function were not in a contextually typed position, the
function’s argument would implicitly have type =any=, and no error
would be issued (unless you are using the
{{{option(--noImplicitAny)}}} option):

#+begin_src js
const handler = function(uiEvent) {
    console.log(uiEvent.button); //<- OK
}
#+end_src

We can also explicitly give type information to the function’s
argument to override any contextual type:

#+begin_src js
window.onscroll = function(uiEvent: any) {
    console.log(uiEvent.button);  //<- Now, no error is given
};
#+end_src

However, this code will log =undefined=, since =uiEvent= has no
property called =button=.

Contextual typing applies in many cases.  Common cases include
arguments to function calls, right hand sides of assignments, type
assertions, members of object and array literals, and return
statements.  The contextual type also acts as a candidate type in best
common type.  For example:

#+begin_src js
function createZoo(): Animal[] {
    return [new Rhino(), new Elephant(), new Snake()];
}
#+end_src

In this example, best common type has a set of four candidates:
=Animal=, =Rhino=, =Elephant=, and =Snake=.  Of these, =Animal= can be
chosen by the best common type algorithm.
* Type Compatibility
* Advanced Types
** Intersection Types
** Union Types
** Type Guards

#+cindex:type guard
#+cindex:@code{typeof}
#+cindex:@code{instanceof}
#+cindex:custom type guard
#+cindex:type guard, types
#+cindex:type guard, custom
A /type guard/ is a statement that results in the type becoming
narrower.  The standard type guards include =typeof= and =instanceof=;
but if that doesn’t cover your situation, you can write your own
custom type guard.

Union types are useful for modeling situations when values can overlap
in the types they can take on.  What happens when we need to know
specifically whether we have a =Fish=, not a =Bird?  A common idiom in
JavaScript to differentiate between two possible values is to check
for the presence of a member.  As we mentioned, you can only access
members that are guaranteed to be in all the constituents of a union
type.

#+begin_src js
interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}

let pet = getSmallPet();

// Each of these property accesses will cause an error
if (pet.swim) {
    pet.swim();
}
else if (pet.fly) {
    pet.fly();
}
#+end_src

#+cindex:type assertion
To get the same code working, we’ll need to use a type assertion:

#+begin_src js
let pet = getSmallPet();

if ((pet as Fish).swim) {
    (pet as Fish).swim();
} else if ((pet as Bird).fly) {
    (pet as Bird).fly();
}
#+end_src

*** Type Guards using =typeof= and =instanceof=

#+cindex:@code{typeof} type guard
{{{heading(Typeof Type Guards)}}}

The =typeof= type guards are recognized in two different forms:

- ~typeof v === "typename"~
- ~typeof v !== "typename"~


{{{noindent}}}where "typename" must be one of:

-"number",
- "string",
- "boolean",
- "symbol".


You don’t need to abstract ~typeof x === "number"~ into its own
function because TypeScript will recognize it as a type guard on its
own.  That means we could just write these checks inline.

#+begin_src js
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
#+end_src

{{{heading(Instanceof Type Guards)}}}

#+cindex:@code{instanceof} type guard
#+cindex:constructor function
=instanceof= type guards are a way of narrowing types using their
constructor function.  The right side of the =instanceof= needs to be
a constructor function, and TypeScript will narrow down to:

- the type of the function’s prototype property if its type is not
  =any=

- the union of types returned by that type’s construct signatures


{{{noindent}}}in that order.

The =instanceof= operator (~<object> instanceof <constructor>~) tests
the presence of ~constructor.prototype~ in object's prototype chain.


#+caption: instanceof Type Guard
#+name:instanceof-type-guard
#+begin_src js
  interface Padder {
      getPaddingString(): string
  }

  class SpaceRepeatingPadder implements Padder {
      constructor(private numSpaces: number) { }
      getPaddingString() {
          return Array(this.numSpaces + 1).join(" ");
      }
  }

  class StringPadder implements Padder {
      constructor(private value: string) { }
      getPaddingString() {
          return this.value;
      }
  }

  function getRandomPadder() {
      return Math.random() < 0.5 ?
          new SpaceRepeatingPadder(4) :
          new StringPadder("  ");
  }

  // Type is 'SpaceRepeatingPadder | StringPadder'
  let padder: Padder = getRandomPadder();

  if (padder instanceof SpaceRepeatingPadder) {
      padder; // type narrowed to 'SpaceRepeatingPadder'
  }
  if (padder instanceof StringPadder) {
      padder; // type narrowed to 'StringPadder'
  }
#+end_src

*** Custom Type Guards

#+cindex:type guard
Notice that we had to use type assertions several times.  It would be
much better if once we performed the check, we could know the type of
pet within each branch.  TypeScript has something called a /type
guard/.  A type guard is some expression that performs a runtime check
that guarantees the type in some scope.

{{{subheading(Using Type Predicates)}}}

#+cindex:type guard, define
#+cindex:type predicate
To define a type guard, we simply need to define a function whose
return type is a type predicate:

#+begin_src js
function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}
#+end_src

=pet is Fish= is our type predicate in this example.  A predicate
takes the form =parameterName is Type=, where =parameterName= must be
the name of a parameter from the current function signature.  Any time
~isFish~ is called with some variable, TypeScript will narrow that
variable to that specific type if the original type is compatible.

#+begin_src js
// Both calls to 'swim' and 'fly' are now okay.

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
#+end_src

Notice that TypeScript not only knows that ~pet~ is a =Fish= in the
~if~ branch; it also knows that in the ~else~ branch, you don’t have a
=Fish=, so you must have a =Bird=.

{{{subheading(Using the in operator)}}}

The ~in~ operator now acts as a narrowing expression for types.

For a ~n in x~ expression, where ~n~ is a string literal or string
literal type and ~x~ is a union type, the =true= branch narrows to
types which have an optional or required property ~n~, and the =false=
branch narrows to types which have an optional or missing property
~n~.

#+begin_src js
function move(pet: Fish | Bird) {
    if ("swim" in pet) {
        return pet.swim();
    }
    return pet.fly();
}
#+end_src
* Modules
#+cindex:ECMAScript 2015
#+cindex:internal module, namespace
#+cindex:namespace, internal module
#+cindex:external module, module
#+cindex:module, external module
In order to align with ECMAScript 2015’s terminology, (namely that
~module X {~ is equivalent to the now-preferred ~namespace X {~), in
TypeScript 1.5, the nomenclature has changed:

- “Internal modules” are now “namespaces”
- “External modules” are now simply “modules”

* Introduction to Modules

** Internal Module Namespaces
#+cindex:namespace, internal module
#+cindex:internal module, namespace
#+cindex:closure, namespace
#+cindex:global variable
Internal modules represent a “namespace” that classes, interfaces,
enums, variables, code segments, and other namespaces can exist inside
of.  They are created inside of a closure just like classes are.
However, modules don’t return a function that gets assigned to a
global variable.  Rather, modules execute a closure /with/ a global
variable as a parameter.  Exported properties are then attached /to/
this global variable.  A module can contain any number of declarations
of any type of object including other modules.  Each of the
declarations inside of a module can be either kept isolated or they
can be exported.  Exported objects will be added to the module’s
instance.

#+cindex:internal module definition
#+cindex:namespace definition
The following is an internal module (“namespace”) definition:

#+begin_src js -n
  module Shapes {
      var origin: IPoint = new Point(0, 0);
      export enum ShapeType {
          Rectangle = 3,
          Circle,
          Line,
          Freehand
      }
      export interface IShape {
          Type: ShapeType;
          Bounds: IBounds;
      }
      export class Shape implements IShape {
          public Type: ShapeType = ShapeType.Rectangle;
          public Bounds: IBounds;
          constructor() {
              this.Bounds = new Bounds();
              this.Bounds.Location = origin;
          }
      }
  }
#+end_src

The =origin= variable is a private instance of the =Point= class
created earlier.  Any expression inside the =Shapes= module has access
to the =origin= variable but since it is not decorated with the
~export~ keyword, it is limited to within the module.

There is a public interface for an object type that will represent a
shape of some sort.  There is also also a new public class that
implements the shape interface and is ready to be drawn on a surface.
This =Shape= class needs to be accessible outside the =Spaces=
namespace so it must be exported.

The =ShapeType= enum belongs within the =Shapes= namespace so its
declaration is included within the module definition as well.

#+cindex:namespace
#+cindex:internal module
There is now an internal module (“namespace”) that has two accessible
named types, the =ShapeType= enum and =Shape= class, and one
inaccessible variable, the =origin= variable, which is part of the
isolated state of the module.  While one will not necessarily need
access to the =ShapeType= enum, it still must be exported for the code
to compile.

Any named types that are used in the definition of another member
*must* be made /as accessible as/ that member.  If this requirement is
not met, compilation will fail.

{{{heading(Accessing Module Members)}}}

Accessing these types is done by providing the module name and then
the type to access. 

: var shape = new Shapes.Shape();
: shape.Type = Shapes.ShapeType.Circle;

This code creates a new =Shape= object and sets it type.

{{{heading(Generated JavaScript Module Code)}}}

#+cindex:JavaScript module code
#+cindex:closure, module
The generated JavaScript code for the module looks similar to the code
generated for enum types.  All of the members of the module are
wrapped in a closure that runs when the module is loaded.  Each of the
exported types is placed on the instance variable that is passed to
the closure that is available to anyone accessing the module.  

Modules also share the ability to be merged that enums do.  This means
that you can separate your code into multiple files and have them
merged into one object during runtime.  The downside to this
implementation of modules is that it takes away the ability to create
interfaces for modules.  However, the ability to organize your code in
whichever manner you choose is far more valuable than any
functionality interfaces would bring to modules.

Here is the resuling JavaScript code for the above module definition:

#+begin_src js -n
  var Shapes;
  (function (Shapes){
      var origin = new Point(0, 0);
      (function (ShapeType) {
          ShapeType[ShapeType["Rectangle"] = 3] = "Rectangle";
          ShapeType[ShapeType["Circle"] = 3] = "Circle";
          ShapeType[ShapeType["Line"] = 3] = "Line";
          ShapeType[ShapeType["Freehand"] = 3] = "Freehand";
      })(Shapes.ShapeType || (Shapes.ShapeType = {}));
      var ShapeType = Shapes.ShapeType;
      var Shape = (function() {
          function Shape() {
              this.Type = 3 /* Rectangle */;
              this.Bounds = new Bounds();
              this.Bounds.Location = origin;
          }
          return Shape;
      })();
  })(Shapes || (Shapes = {}));
#+end_src

** Creating Module Namespaces
There are two ways to provide module namespaces in TypeScript.  One
way is to nest the modules inside of each other.  The other way is to
define them as part of the module declaration.

#+begin_src js -n
  module Animals {
      /* nesting modules inside of each other */
      export module Reptiles {
          export var snake = "snake";
      }
  }

  module.Animals.Mammels {
      /* defining modules as part of the module declaration */
      export var monkey = "monkey";
  }
#+end_src

Both of the module declarations shown above are valid and the
JavaScript output from both declarations is exactly the same.  Which
style you choose is a matter of preference.  The compiler will treat
them as equivalent.  Further, the means of accessing the namespaces is
identical.

** Module Imports
TypeScript provides a keyword opposite to the ~export~ keyword that
allows you to create an alias to members of another module.  The
~import~ keyword creates a new local reference to exported types from
other modules.

: import Bounds = Drawing.Bounds

The alias can be used as both a type annotation and as its object type.

* Module Details
#+cindex:ECMAScript 2015
Starting with ECMAScript 2015, JavaScript has a concept of
modules.  TypeScript shares this concept.

{{{heading(Modules Have Their Own Scope)}}}

#+cindex:module scope
#+cindex:scope, module
Modules are executed within their own scope, not in the global scope;
this means that variables, functions, classes, etc. declared in a
module are not visible outside the module unless they are explicitly
exported using one of the export forms.  Conversely, to consume a
variable, function, class, interface, etc. exported from a different
module, it has to be imported using one of the import forms.

{{{heading(Modules are Declarative)}}}

Modules are declarative; the relationships between modules are
specified in terms of imports and exports at the file level.

{{{heading(Module Loaders)}}}

#+cindex:module loader
#+cindex:CommonJS module loader
#+cindex:RequireJS module loader
Modules import one another using a module loader.  At runtime the
module loader is responsible for locating and executing all
dependencies of a module before executing it.  Well-known module
loaders used in JavaScript are Node.js’s loader for CommonJS modules
and the RequireJS loader for AMD modules in Web applications.

{{{heading(What Makes a Module)}}}

#+cindex:module
#+cindex:script
In TypeScript, just as in ECMAScript 2015, any file containing a
top-level import or export is considered a module.  Conversely, a file
without any top-level import or export declarations is treated as a
script whose contents are available in the global scope (and therefore
to modules as well).

** Export Keyword
#+cindex:@code{export} keyword
Any declaration (such as a variable, function, class, type alias, or
interface) can be exported by adding the =export= keyword.  The
=export= keyword can also be used in a statement, in which the
exported object can be aliased.

#+begin_src js
export interface <Name> { ... }
export const <id> = <expression>;
export { <Name> as <alias> };
#+end_src

{{{heading(Re-Exports)}}}

#+cindex:re-export
Often modules extend other modules, and partially expose some of their
features.  A re-export does not import it locally, or introduce a local
variable.

#+begin_src js
<implementation>

export { <original-name> as <new-name> from "./<path>";
#+end_src

Optionally, a module can wrap one or more modules and combine all
their exports using export * from "module" syntax.

#+begin_src js
export * from "./StringValidator"; // exports 'StringValidator' interface
export * from "./ZipCodeValidator";  // exports 'ZipCodeValidator' and const 'numberRegexp' class
export * from "./ParseIntBasedZipCodeValidator"; //  exports the 'ParseIntBasedZipCodeValidator' class
                                                 // and re-exports 'RegExpBasedZipCodeValidator' as alias
                                                 // of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts'
                                                 // module.
#+end_src

** Import Keyword
Importing an exported declaration is done through using one of the
import forms below:

{{{heading(Import a single export from a module)}}}

#+begin_src js
import { <object> } from "./<path>";
#+end_src

Imports can also be renamed:

#+begin_src js
import { <object> as <alias> } from "./<path>";
#+end_src

{{{heading(Import the entire module into a single variable, and use it
to access the module exports)}}}

#+begin_src js
import * as <name> from "./<path";
#+end_src

{{{heading(Import a module for side-effects only)}}}

Though not recommended practice, some modules set up some global state
that can be used by other modules. These modules may not have any
exports, or the consumer is not interested in any of their exports. To
import these modules, use:

#+begin_src js
import "./<path>";
#+end_src

** Default Exports
#+cindex:default exports
#+cindex:@code{default} keyword
Each module can optionally export a default export.  Default exports
are marked with the keyword =default=; and there can only be one
default export per module.  =default= exports are imported using a
different import form.

#+begin_src js
export default <object>;
#+end_src

#+begin_src js
import <object> from "<path>";
#+end_src

Classes and function declarations can be authored directly as default
exports.  Default export class and function declaration names are
optional.  =default= exports can also be just values.

#+begin_src js
export default class { ... }
#+end_src

or

#+begin_src js
export default function (<params>) { ... }
#+end_src

#+begin_src js
import <name> from "./<path>";
#+end_src

** export = and import =
#+cindex:@code{export =}
#+cindex:@code{import =}
#+cindex:CommonJS
#+cindex:AMD
Both CommonJS and AMD generally have the concept of an exports object
which contains all exports from a module.  They also support replacing
the =exports= object with a custom single object.  Default exports are
meant to act as a replacement for this behavior; however, the two are
incompatible.  TypeScript supports ~export =~ to model the traditional
CommonJS and AMD workflow.

The ~export =~ syntax specifies a single object that is exported from
the module.  This can be a class, interface, namespace, function, or
enum.  When exporting a module using ~export =~, TypeScript-specific
~import module = require("module")~ must be used to import the module.

#+begin_src js
...
export = <Object>
#+end_src

#+begin_src js
import <name> = require("./<path>");
#+end_src

* Declaration Files
#+cindex:declaration file
This guide is designed to teach you how to write a high-quality
TypeScript Declaration File.

In this guide, we’ll assume basic familiarity with the TypeScript
language.

{{{heading(declaration Keyword)}}}

#+cindex:@code{declare} keyword
Since module declaration files have to live in ~.d.ts~ files and so
can’t contain values, when you declare module types you need to use
the ~declare~ keyword to affirm that values of the given type really
are exported by your module.

{{{subheading(Some Declarations)}}}

- var a=1 :: declare var a: number

- let a=1 :: declare let a: number

- const a=1 :: declare const a: 1

- function a(b) { return b.toFixed } :: declare function a(b: number):
     string

- class A { b() { return 3 } } :: declare class A { b (): number }

- namespace A {} :: declare namespace A {}

- type A = number :: type A = number

- interface A { b? : string } :: interface A { b? : string }

{{{heading(Sections)}}}

The guide is broken down into the following sections.

{{{subheading(Library Structures)}}}

The Library Structures guide helps you understand common library
formats and how to write a correct declaration file for each format.
If you’re editing an existing file, you probably don’t need to read
this section.  Authors of new declaration files must read this section
to properly understand how the format of the library influences the
writing of the declaration file.

{{{subheading(By Example)}}}

Many times, we are faced with writing a declaration file when we only
have examples of the underlying library to guide us.  The By Example
section shows many common API patterns and how to write declarations
for each of them.  This guide is aimed at the TypeScript novice who
may not yet be familiar with every language construct in TypeScript.

{{{subheading(Do's and Don'ts)}}}

Many common mistakes in declaration files can be easily avoided.  The
Do’s and Don’ts section identifies common errors, describes how to
detect them, and how to fix them.  Everyone should read this section
to help themselves avoid common mistakes.

{{{subheading(Deep Dive)}}}

For seasoned authors interested in the underlying mechanics of how
declaration files work, the Deep Dive section explains many advanced
concepts in declaration writing, and shows how to leverage these
concepts to create cleaner and more intuitive declaration files.

{{{subheading(Templates)}}}

In Templates you’ll find a number of declaration files that serve as a
useful starting point when writing a new file.  Refer to the
documentation in Library Structures to figure out which template file
to use.

{{{subheading(Publish to npm)}}}

The Publishing section explains how to publish your declaration files
to an npm package, and shows how to manage your dependent packages.

{{{subheading(Find and Install Declaration Files)}}}

For JavaScript library users, the Consumption section offers a few
simple steps to locate and install corresponding declaration files.

* Supplementary Programs
:PROPERTIES:
:appendix: t
:END:

** Example Programs in TypeScript

*** OO CONCEPTS IN TYPESCRIPT
:PROPERTIES:
:source:   http://www.software-architects.com/devblog/2012/11/02/Sample-Code-for-TypeScript-Article-in-WindowsDeveloper-Magazine
:title:    SAMPLE CODE FOR TYPESCRIPT ARTICLE IN WINDOWS.DEVELOPER MAGAZINE
:date:     02 November 2012
:END:

This program contains a larger code sample demonstrating some key
concepts of the new language.

The first sample deals with the TypeScript language. It demonstrates
some OO concepts of the language:

#+caption:Demonstration of OO Concepts in TypeScript
#+name:crm-module
#+begin_src js :tangle examples/crm-module.ts
// Define a top-level module
module CrmModule {
  // Define an interface that specifies what a person must consist of.
  export interface IPerson {
    firstName: string;
    lastName: string;
  }

  // Note that Person would not need to specify "implements IPerson"
  // explicitely. Even if the "implements" clause would not be there,
  // Person would be compatible with IPerson because of structural subtyping.
  export class Person implements IPerson {
    private isNew: bool;       // a private member only accessible inside Person
    public firstName: string;  // a public member accessible from outside

    // Here you see how to define a constructor
    // Note the keyword "public" used for parameter "lastName". It
    // makes "lastName" a public property. "firstName" is assigned manually.
    constructor(firstName: string, public lastName: string) {
      this.firstName = firstName;
    }

    // A public method...
    public toString() {
      return this.lastName + ", " + this.firstName;
    }

    // A public get accessor...
    public get isValid() {
      return this.isNew ||
        (this.firstName.length > 0 && this.lastName.length > 0);
    }

    // Note the function type literal used for the "completeCallback" parameter.
    // "repository" has no type. Therefore it is of type "Any".
    public savePerson(repository, completedCallback: (bool) => void) {
      var code = repository.saveViaRestService(this);
      completedCallback(code === 200);
    }
  }

  // Create derived classes using the "extends" keyword
  export class VipPerson extends Person {
    // Note that "VipPerson" does not define a constructor. It gets a
    // constructor with appropriate parameters from its base class
    // automatically.

    // Note how we override "toString" here. Use "super" to access
    // the base class.
    public toString() {
      return super.toString() + " (VIP)";
    }
  }

  // Define a nested module inside of CrmModule
  export module Sales {
    export class Opportunity {
      public potentialRevenueEur: number;
      public contacts: IPerson[];      // Array type

      // Note that we use the "IPerson" interface here.
      public addContact(p: IPerson) {
        this.contacts.push(p);
      }

      // A static member...
      static convertToUsd(amountInEur: number): number {
        return amountInEur * 1.3;
      }
    }
  }
}
#+end_src

{{{heading(Script Using CrmModule)}}}

#+caption:Script Using CrmModule
#+name:crm-script.ts
#+begin_src js :tangle examples/crm-script.ts
import CrmModule from './crm-module';

// Note how we instanciate the Person class here.
var p: CrmModule.Person;
p = new CrmModule.Person("Max", "Muster");

// Change the HTML DOM via TypeScript. Try to play around with this code
// in the TypeScript Playground and you will see that you have IntelliSense
// when working with the DOM. Accessing the DOM is type safe.
var button = document.createElement('button')
button.innerText = p.toString()
button.onclick = function() {
  alert("Hello" + p.firstName)
}
document.body.appendChild(button)

// Call a method and pass a callback function.
var r = { 
  saveViaRestService: function (p: CrmModule.Person) {
    alert("Saving " + p.toString());
    return 200;
  }
};
p.savePerson(r, function(success: string) { alert("Saved"); });

// Create an instance of the derived class.
var v: CrmModule.VipPerson;
v = new CrmModule.VipPerson("Tom", "Turbo");
// Note how we access the get accessor here.
if (!v.isValid) {
  alert("Person is invalid");
}
else {
  // Not that "toString" calls the overridden version from the derived class
  // VipPerson.
  alert(v.toString());
}

// Note how we import a module here and assign it the alias "S".
import S = CrmModule.Sales;
var s: S.Opportunity;
s = new S.Opportunity();
s.potentialRevenueEur = 1000;
// Note structural subtyping here. You can call "addContact" with
// any object type compatible with IPerson.
s.addContact(v);
s.addContact({ firstName: "Rainer", lastName: "Stropek" });
s.addContact(<CrmModule.IPerson> { firstName: "Rainer", lastName: "Stropek" });
var val = S.Opportunity.convertToUsd(s.potentialRevenueEur);
#+end_src

*** Modules in TypeScript

#+caption:Modules in TypeScript
#+name:modules-in-typescript
#+begin_src js :tangle examples/crm.ts
module Crm {
    export class Customer {
        constructor(public custName: string) {
        }
    }
}

module Crm {
    export class Opportunity {
        constructor(public customer: Customer) {
        }
    }
}

var classesInCrmModule = "";
for(var key in Crm)
{
     classesInCrmModule += key + " ";

}
document.body.innerText = classesInCrmModule;
#+end_src

*** Interfaces and Ambient Declarations

#+caption:Interfaces and Ambient Declarations
#+name:jQuery.d.ts
#+begin_src js :tangle examples/jQuery.d.ts
interface JQueryEventObject extends Event {
  preventDefault(): any;
}

interface JQuery {
  ready(handler: any): JQuery;
  click(handler: (eventObject: JQueryEventObject) => any): JQuery;
}

interface JQueryStatic {
  (element: Element): JQuery;
  (selector: string, context?: any): JQuery;
}

declare var $: JQueryStatic;
#+end_src

{{{heading(App.ts)}}}

#+caption:Application
#+name:app.ts
#+begin_src js :tangle examples/app.ts
/// <reference path="jQuery.d.ts" />

$(document.body).ready(function(){
    alert("Loaded");
    $("a").click(function(event) {
        alert("As you can see, the link no longer took you to timecockpit.com");
        event.preventDefault();
   });
});
#+end_src

#+caption:Default HTML
#+name:default-html
#+begin_src js :tangle examples/default.html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>jQuery from TypeScript</title>
    <link rel="stylesheet" href="app.css" type="text/css" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script src="app.js"></script>
</head>
<body>
    <h1>jQuery from TypeScript</h1>
    <div id="content">
        <a href="http://www.timecockpit.com">Click me!</a>
    </div>
</body>
</html>
#+end_src

** Using TypeScript with React
- https://www.typescriptlang.org/docs/handbook/react-&-webpack.html


This guide will teach you how to wire up TypeScript with React and
webpack.

If you’re starting a brand new project, take a look at the [[https://create-react-app.dev/docs/adding-typescript][React Quick
Start guide]] first.

*** Adding TypeScript to a React Project
- https://create-react-app.dev/docs/adding-typescript/

Note: this feature is available with react-scripts@2.1.0 and higher.

**** Installation
To start a new Create React App project with TypeScript, you can run:

: yarn create react-app my-app --typescript

To add TypeScript to a Create React App project, first install it:

: yarn add typescript @types/node @types/react @types/react-dom @types/jest

Next, rename any file to be a TypeScript file (e.g. ~src/index.js~ to
~src/index.tsx~) and restart your development server!

Type errors will show up in the same console as the build one.  You'll
have to fix these type errors before you continue development or build
your project.

For advanced configuration, see [[https://create-react-app.dev/docs/advanced-configuration][here]].

**** Getting Started
You are not required to make a ~tsconfig.json~ file, as one will be
made for you.  You are allowed to edit the generated TypeScript
configuration.

See a [[https://www.typescriptlang.org/play/index.html?jsx=2&esModuleInterop=true&e=196#example/typescript-with-react][TypeScript example in React]].

See [[https://github.com/typescript-cheatsheets/react-typescript-cheatsheet#reacttypescript-cheatsheets][React + TypeScript Cheatsheets]]

*** Laying Out the Project
Start with a new directory, for example: ~proj/~.

: mkdir proj && cd proj

Structure the project like so:

- proj/
  - dist/
  - src/
    - components/


TypeScript files will start out in your ~src/~ folder, run through the
TypeScript compiler, then webpack, and end up in a ~main.js~ file in
~dist/~.  Any components that we write will go in the
~src/components/~ folder.

: mkdir src && cd src && mkdir components && cd ..

Webpack will create the ~dist/~ directory.

*** Initializing the Project
Turn this project into an NPM package:

: yarn init -yp

*** Installing the Project Dependencies
First, install the development dependencies Webpack and TypeScript and
related packages:

: yarn add --dev webpack wepback-cli typescript ts-loader source-map-loader

Next, install React, React-DOM, and their TypeScript types:

: yarn add react react-dom
: yarn add --dev @types/react @types/react-dom

~ts-loader~ helps Webpack compile your TypeScript code using the
TypeScript’s standard configuration file named ~tsconfig.json~.  Note
that you could also use ~awesome-typescript-loader~.

~source-map-loader~ uses any sourcemap outputs from TypeScript to
inform webpack when generating its own sourcemaps.  This will allow
you to debug your final output file as if you were debugging your
original TypeScript source code.

*** Adding a TypeScript Configuration File
Create a ~tsconfig.json~ file, which contains a list of your input
files as well as all your compilation settings.  Create a new file in
your project root named ~tsconfig.json~ and fill it with the following
contents:

#+begin_src js -n
  {
      "compilerOptions": {
          "outDir": "./dist/",
          "sourceMap": true,
          "noImplicitAny": true,
          "module": "commonjs",
          "target": "es6",
          "jsx": "react"
      }
  }
#+end_src
*** Writing Some Code
First, create a file named ~Hello.tsx~ in ~src/components~ and write
the following:

#+begin_src js -n
  import * as React from "react";

  export interface HelloProps { compiler: string; framework: string; }

  export const Hello = (props: HelloProps) => <h1>Hello from {props.compiler} and {props.framework}!</h1>;
#+end_src

Note that while this example uses function components, we could also
make our example a little classier as well.

#+begin_src js -n
  import * as React from "react";

  export interface HelloProps { compiler: string; framework: string; }

  // 'HelloProps' describes the shape of props.
  // State is never set so we use the '{}' type.
  export class Hello extends React.Component<HelloProps, {}> {
      render() {
          return <h1>Hello from {this.props.compiler} and {this.props.framework}!</h1>;
      }
  }
#+end_src

Next, let’s create an ~index.tsx~ in ~src/~ with the following source:

#+begin_src js +n
  import * as React from "react";
  import * as ReactDOM from "react-dom";

  import { Hello } from "./components/Hello";

  ReactDOM.render(
      <Hello compiler="TypeScript" framework="React" />,
      document.getElementById("example")
  );
#+end_src

We just imported our =Hello= component into ~index.tsx~.  Notice that
unlike with "react" or "react-dom", we used a relative path to
~Hello.tsx~ --- this is important.  If we hadn’t, TypeScript would’ve
instead tried looking in our ~node_modules~ folder.

We’ll also need a page to display our Hello component.  Create a file
at the root of ~proj/~ named ~index.html~ with the following contents:

#+begin_src html -n
  <!DOCTYPE html>
  <html>
      <head>
          <meta charset="UTF-8" />
          <title>Hello React!</title>
      </head>
      <body>
          <div id="example"></div>

          <!-- Dependencies -->
          <script src="./node_modules/react/umd/react.development.js"></script>
          <script src="./node_modules/react-dom/umd/react-dom.development.js"></script>

          <!-- Main -->
          <script src="./dist/main.js"></script>
      </body>
  </html>
#+end_src

Notice that we’re including files from within ~node_modules~.  React
and React-DOM’s npm packages include standalone ~.js~ files that you
can include in a web page, and we’re referencing them directly to get
things moving faster.  Feel free to copy these files to another
directory, or alternatively, host them on a content delivery network
(CDN).  Facebook makes CDN-hosted versions of React available, and you
can read more about that [[http://facebook.github.io/react/downloads.html#development-vs.-production-builds][here]].

*** Creating a Webpack Configuration File
Create a ~webpack.config.js~ file at the root of the project
directory.

#+begin_src js -n
  module.exports = {
      mode: "production",

      // Enable sourcemaps for debugging webpack's output.
      devtool: "source-map",

      resolve: {
          // Add '.ts' and '.tsx' as resolvable extensions.
          extensions: [".ts", ".tsx"]
      },

      module: {
          rules: [
              {
                  test: /\.ts(x?)$/,
                  exclude: /node_modules/,
                  use: [
                      {
                          loader: "ts-loader"
                      }
                  ]
              },
              // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.
              {
                  enforce: "pre",
                  test: /\.js$/,
                  loader: "source-map-loader"
              }
          ]
      },

      // When importing a module whose path matches one of the following, just
      // assume a corresponding global variable exists and use that instead.
      // This is important because it allows us to avoid bundling all of our
      // dependencies, which allows browsers to cache those libraries between builds.
      externals: {
          "react": "React",
          "react-dom": "ReactDOM"
      }
  };
#+end_src

To avoid bundling all of React into the same file, which increases
compilation time and browsers will typically be able to cache a
library if it doesn't change, use the =externals= property and include
React and React-DOM.

Ideally, we’d just import the React module from within the browser,
but most browsers still don’t quite support modules yet.  Instead
libraries have traditionally made themselves available using a single
global variable like jQuery or _.  This is called the “namespace
pattern”, and webpack allows us to continue leveraging libraries
written that way.  With our entry for "react": "React", webpack will
work its magic to make any import of "react" load from the React
variable.

*** Running the Project
Just run:

: yarn wepback

and open up ~index.html~ in a browser.  You should see a page that
says “Hello from TypeScript and React!”

** Tide for Emacs
=Tide= --- TypeScript Interactive Development Environment for Emacs

- https://github.com/ananthakumaran/tide

*** Tide Installation
- Install ~node.js v0.12.0~ or greater.

- Make sure ~tsconfig.json~ or ~jsconfig.json~ is present in the root
  folder of the project.

- =Tide= is available in [[http://melpa.org/#/tide][melpa]].  You can install =tide= via
  ~package-install M-x package-install [ret] tide~

*** Tide Configuration

#+begin_src emacs-lisp -n
(defun setup-tide-mode ()
  (interactive)
  (tide-setup)
  (flycheck-mode +1)
  (setq flycheck-check-syntax-automatically '(save mode-enabled))
  (eldoc-mode +1)
  (tide-hl-identifier-mode +1)
  ;; company is an optional dependency. You have to
  ;; install it separately via package-install
  ;; `M-x package-install [ret] company`
  (company-mode +1))

;; aligns annotation to the right hand side
(setq company-tooltip-align-annotations t)

;; formats the buffer before saving
(add-hook 'before-save-hook 'tide-format-before-save)

(add-hook 'typescript-mode-hook #'setup-tide-mode)
#+end_src

*** Tide Format Options

#+cindex:tide format options
#+cindex:format options, tide
Format options can be specified in multiple ways.

{{{heading(via elisp)}}}

#+findex:tide-format-options
#+name:tide-format-options
#+begin_src emacs-lisp
(setq tide-format-options 
      '(:insertSpaceAfterFunctionKeywordForAnonymousFunctions t
        :placeOpenBraceOnNewLineForFunctions nil))
#+end_src

{{{heading(via tsfmt.json)}}}

~tsfmt.json~ should be present in the root folder along with
~tsconfig.json~

#+pindex:@code{tsfmt.json}
#+name:tsfmt.json
#+begin_src js
{
  "indentSize": 4,
  "tabSize": 4,
  "insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces": false,
  "placeOpenBraceOnNewLineForFunctions": false,
  "placeOpenBraceOnNewLineForControlBlocks": false
}
#+end_src

** Makefile
:PROPERTIES:
:appendix: t
:END:
#+caption:Makefile
#+name:Makefile
#+begin_src makefile -n :tangle Makefile
SOURCE=TypeScript-Guide
DIRS = examples

info:	$(SOURCE).texi
	makeinfo $(SOURCE).texi

pdf:	$(SOURCE).texi
	pdftexi2dvi -q $(SOURCE).texi; \
	open $(SOURCE).pdf

clean-dirs:
	rm -rf $(DIRS)
clean-texi:
	-rm *.texi
clean-info:
	-rm *.info
clean-pdf:
	-rm *.pdf
clean-aux:
	-rm *.{aux,toc,log,cp,cps,pg,pgs,fn,fns}

clean: clean-texi clean-info clean-pdf clean-aux clean-dirs

phony:clean-texi clean-info clean-pdf clean-aux clean
#+end_src

* Concept Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:

* Program Index
:PROPERTIES:
:index:    pg
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:unnumbered: t
:index:    fn
:END:

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright {{{noindent}}}\copy 2019 {{{author}}} {{{theVersion}}}

* Macro Definitions                                                :noexport:

#+macro:theVersion Version {{{version}}} {{{date}}}
#+macro:noindent @@texinfo:@noindent @@
#+macro:heading @@texinfo:@heading@@ $1
#+macro:subheading @@texinfo:@subheading@@ $1
#+macro:command @@texinfo:@command{@@$1@@texinfo:}@@
#+macro:option @@texinfo:@option{@@$1@@texinfo:}@@
#+macro:file @@texinfo:@file{@@$1@@texinfo:}@@

* Export Options                                                   :noexport:

** Texinfo Export Options

#+options: H:4
#+texinfo_filename:typescript-guide.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+subtitle:{{{theVersion}}}
#+subauthor:LOLH
#+texinfo_dir_category:Languages
#+texinfo_dir_title:TypeScript
#+texinfo_dir_desc:How to program using TypeScript
#+texinfo_printed_title:TypeScript Guide in Print

* Local Variables                                                  :noexport:

* Footnotes

[fn:1]~@types/node~ is necessary for the ~require~ keyword and the
~exports~ object variable. 
# Local Variables:
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
